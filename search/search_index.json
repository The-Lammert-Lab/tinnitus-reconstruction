{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tinnitus reconstruction via reverse correlation","text":"<p>This project works to develop a method for characterizing the sounds  experienced by tinnitus patients with potential for characterizing a  wider range of sounds than currently possible.  The approach is based on reverse correlation, an established behavioral  method widely used in psychophysics for unconstrained  characterization of internal perceptual representations.</p> <p></p>"},{"location":"docs_styleguide/","title":"Documentation Styleguide","text":"<p>This is a styleguide for the documentation of tinnitus-project.  Documentation is created by running <code>build_docs.py</code>, which processes every <code>.m</code> file in the repository. This guide is intended as both a reference for consistency of documentation and syntax processable by <code>build_docs.py</code>.</p>"},{"location":"docs_styleguide/#header-files","title":"Header Files","text":"<p>In order for documentation to be written for the contents of a directory, there must exist a file in the <code>tinnitus-project/docs</code> directory named <code>dirname-head.md</code>, where <code>dirname</code> is the name of the directory for which the documentation is being generated.  The contents of this file will be placed at the beginning of the documentation page, after which in-file documentation will be written.  This header file is only editable directly and is not overwritten at each regeneration of the documentation. </p>"},{"location":"docs_styleguide/#beginning-documentaiton","title":"Beginning Documentaiton","text":"<p>For all functions and scripts, the documentation must be in the form of comments preceeding all code in the file (Abstract Class Documentation is an exception to this).  In order for a code file to be incorporated into the documentation, the filename, excluding <code>.m</code> must be written at the beginning of the documentation text.  Be sure to place three <code>#</code> signs in front of the filename so that the file is formatted as \"Heading level 3\". For example, documentation for <code>Protocol.m</code> would begin with: <code>% ### Protocol</code>.</p> <p>Note</p> <p>Documentation will still be created so long as the filename is present, regardless of heading style.</p> <p>If one wishes to exclude documentation from the site for any reason, simply do not put the filename as a standalone comment line.</p>"},{"location":"docs_styleguide/#ending-documentation","title":"Ending Documentation","text":"<p>For all functions and scripts, the recorded documentation will end at the beginning of the code.  However, for scripts (which do not have a clear <code>function</code> demarcation for the beginning of the code), it is best practice to mark the desired end of the documentation with <code>% End of documentation</code> (case insensitive). This will avoid capturing any code-specific comments, such as section headers, in the documentation.</p>"},{"location":"docs_styleguide/#formatting","title":"Formatting","text":"<p>At minimum, all documentation should include two things:</p> <ul> <li>A description of the purpose of the code<ul> <li>Plain English description of what the code does.</li> </ul> </li> <li>A list of outputs<ul> <li>Written with the header <code>**OUTPUTS:**</code> followed by a blank new line and the ouputs listed on subsequent lines with <code>-</code> markers. Place a colon before the output description and enclose any dimensionality information (e.g., matrix size) within backticks.  Scripts should also have outputs listed even for figures, saved files, etc. See the here for an example.</li> </ul> </li> </ul> <p>Additional information may include:</p> <ul> <li>An example of a function call<ul> <li>This is most useful if there are optional arguments to illustrate the ways in which the function may be called. Enclose the example using a fenced code block as in: <pre><code>```matlab\nfunction call example\n```\n</code></pre></li> </ul> </li> <li>A list of arguments<ul> <li>Written with the header <code>**ARGUMENTS:**</code> followed by a blank new line and the arguments listed on subsequent lines with <code>-</code> markers. Place a colon before the argument description and enclose any dimensionality information (e.g., matrix size) within backticks.  Be sure to note optional arguments and their default values. See the here for an example.</li> </ul> </li> <li> <p>A \"See Also\" section</p> <ul> <li>A list of other functions relevant to the current file.  Write <code>See Also:</code> (case insensitive, colon not necessary) on its own line followed by the relevant filenames on subsequent, individual lines. Documentation will autoformat to the proper call-out box. </li> </ul> <p>For basic scripts and functions, just write the filename: <pre><code>% See Also: \n% collect_reconstructions\n% collect_data\n% config2table\n</code></pre> Class methods must be written as <code>classname.method</code>: <pre><code>% See Also: \n% PowerDistributionStimulusGeneration.from_file\n</code></pre> To preformat the reference, use the syntax <code>* [reference](link)</code>,  where <code>reference</code> is the text that will be hyperlinked, and <code>link</code> is the redirection location.  This is useful for references to other repositories or documentation: <pre><code>% See Also: \n% * [ReadYaml](https://github.com/llerussell/ReadYAML/blob/master/ReadYaml.m)\n</code></pre></p> </li> </ul>"},{"location":"docs_styleguide/#example","title":"Example","text":"<p>An example of a fully documented and formatted function:</p> <pre><code>% ### binnedrepr2spect  \n% \n% ```matlab\n%   T = binnedrepr2spect(binned_repr, B)\n%   T = binnedrepr2spect(binned_repr, B, n_bins)\n% ```\n%\n% Get the stimuli spectra from a binned representation.\n%\n% **ARGUMENTS:**\n% \n%   - binned_repr: `n_trials x n_bins` matrix\n%       representing the amplitude in each frequency bin\n%       for each trial.\n%   - B: `1 x n_frequencies` vector\n%       representing the bin numbers\n%       (e.g., `[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]`)\n%   - n_bins: `1 x 1` scalar\n%       representing the number of bins\n%       if not passed as an argument,\n%       it is computed from the maximum of B\n% \n% **OUTPUTS:**\n% \n%   - T: `n_trials x n_frequencies` matrix\n%       representing the stimulus spectra\n% \n% See Also:\n% spect2binnedrepr\n</code></pre> <p>Note</p> <p>Be sure to avoid too much text on a single line so as to maintain readability of the documentation within the file itself.</p>"},{"location":"docs_styleguide/#abstract-class-documentation","title":"Abstract Class Documentation","text":"<p>For abstract classes, the preferred documentation style is slightly different.  Because the abstract methods are all written within the same file, it improves code readability to keep the documentation inside each function, rather than before the <code>function</code> statement as done elsewhere.  Choosing to place comments before or after the <code>function</code> statement does not affect the generated documentation, only the readability for those working directly with the code. </p>"},{"location":"install/","title":"Installation and setup guide","text":"<p>For most users, it is best to install the MATLAB toolbox from the latest Release. For development, clone the following projects:</p> <ul> <li>mtools</li> <li>tinnitus-project</li> <li>ReadYAML (only for legacy use)</li> <li>yaml</li> </ul> <p>Then add the functions to your path. The commands should look similar to this:</p> <pre><code>addpath ~/code/yaml\naddpath ~/code/srinivas.gs_mtools/src\nsavepath\n</code></pre> <p>Finally, in the <code>tinnitus-project/code</code> directory, run <code>setup.m</code> as a MATLAB script.</p>"},{"location":"scripts-head/","title":"Scripts","text":"<p>Housed within this folder are data processing and analysis scripts. </p>"},{"location":"scripts/","title":"Scripts","text":"<p>Housed within this folder are data processing and analysis scripts. </p>"},{"location":"scripts/#adjust_individual_resynth","title":"adjust_individual_resynth","text":"<p>A simple script to run the adjustment protocol for a given config file</p>"},{"location":"scripts/#analyze_consistency","title":"analyze_consistency","text":"<p>This script compares the consistency in reconstructions from  data collected several days in a row by NB with all settings the same</p> <p>Setup</p>"},{"location":"scripts/#analyze_phase2","title":"analyze_phase2","text":"<p>This script contains two different analysis options for assessing the functionality of a \"phase 2\" in RC experiments. Phase 2 consists of taking the original/standard RC reconstruction and using it as the basis for generating new stimuli. Those options can be seen in the local function <code>local_create_files_and_stimuli_phaseN</code></p>"},{"location":"scripts/#compare_norena","title":"compare_norena","text":"<p>Run simulated observer on Norena stimgen  and two UniformPrior options (1 bin filled and multiple bins filled) and visualize the results</p>"},{"location":"scripts/#compare_recons","title":"compare_recons","text":"<p>The purpose of this script is to assess the qualitative effect of the peak-sharpening procedure.  Runs adjust_resynth.m followed by follow_up.m on select configs/associated data.</p>"},{"location":"scripts/#compare_stim_and_recon","title":"compare_stim_and_recon","text":"<p>Runs the simulated observer on two UniformPrior options  (1 bin filled and multiple bins filled) and uses several different reconstruction methods (ten scale, ridge regression, linear) and visualizes the results</p>"},{"location":"scripts/#hyperparameter_sweep_custom","title":"hyperparameter_sweep_custom","text":"<p>Hyperparameter Sweep Custom Stimulus</p> <p>Evaluate hyperparameters of stimulus generation using the 'custom' stimulus paradigm. Evaluate hyperparameters over different target signals.</p>"},{"location":"scripts/#optimize_hiergauss","title":"optimize_hierGauss","text":"<p>Run a grid search on HierarchicalGaussian stimgen parameters to determine the best combination of broad, medium, and narrow bases.</p>"},{"location":"scripts/#optimize_resynth","title":"optimize_resynth","text":"<p>Determine the best mult and binrange parameters for resynthesis.  This can be used to extrapolate a good range  to present to subjects for a given bin number.</p>"},{"location":"scripts/#patient_reconstructions","title":"patient_reconstructions","text":"<p>Generate reconstructions and visualizatinos for non-target sound data Includes lots of flags for response prediction analysis NOTE: should also work with make_figures_paper2 (not recently tested though)</p>"},{"location":"scripts/#pilot_reconstructions","title":"pilot_reconstructions","text":"<p>Compute reconstructions for the pilot data experiment (with target signal). This code assumes that each each experiment uses the same number of bins  and that the reconstructions should be done over the bin representation.</p> <p>OUTPUTS: - T: a data table that contains information about the experiments and their reconstructions</p>"},{"location":"scripts/#predict_on_tsfdata","title":"predict_on_TSFdata","text":"<p>Run just the cross validation section on data used to train ML model Uses data formatted to be digestable by the TinnitusStimulusFitter package.</p>"},{"location":"scripts/#reconstruction_viz","title":"reconstruction_viz","text":"<p>Visualization for reconstructions Run <code>pilot_reconstructions.m</code> first to generate recons, etc.</p>"},{"location":"scripts/#survey_viz","title":"survey_viz","text":"<p>This script collects and analyzes subjective rankings from ompare_recons.m</p>"},{"location":"scripts/#target_signal_sparsity","title":"target_signal_sparsity","text":"<p>Quantify the sparsity of the target signals (ATA tinnitus examples) in the DCT basis.</p>"},{"location":"stimulus_generation-head/","title":"Stimulus generation head","text":"<p>This is sample header text for stimulus_generation-head</p>"},{"location":"utils-head/","title":"Utilities","text":"<p>This folder stores many helpful, and in some cases critical utilities. This folder as added to the path via <code>setup.m</code>. Some files are not original to this project, in which case documentation and credit is clearly maintained.</p>"},{"location":"utils/","title":"Utilities","text":"<p>This folder stores many helpful, and in some cases critical utilities. This folder as added to the path via <code>setup.m</code>. Some files are not original to this project, in which case documentation and credit is clearly maintained.</p>"},{"location":"utils/#adjust_volume","title":"adjust_volume","text":"<p>For use in A-X experimental protocols. <code>adjust_volume</code> is a utility to dynamically adjust the target sound volume via a scaling factor. Opens a GUI using a standard MATLAB figure window  with a slider for scaling the target sound audio  and a button for replaying the sound compared to an unchanged stimulus noise.  </p> <p>ARGUMENTS:</p> <ul> <li>target_sound: <code>n x 1</code> vector, the target sound.</li> <li>target_fs: <code>1 x 1</code> scalar, the frequency of target_sound.</li> <li>stimuli: <code>n x 1</code> vector, a sample stimulus sound.</li> <li>Fs: <code>1 x 1</code> scalar, the frequency of the sample stimuli.</li> <li>scale_factor: <code>1 x 1</code> scalar, the scalar by which to multipy the target sound. default: <code>1.0</code>.</li> </ul> <p>OUTPUTS:</p> <ul> <li>scale_factor: <code>1 x 1</code> scalar,  the scalar by which the target signal is multipled  that results in the preferred volume chosen by the user.</li> </ul>"},{"location":"utils/#allcomb","title":"allcomb","text":"<p>ALLCOMB - All combinations B = ALLCOMB(A1,A2,A3,...,AN) returns all combinations of the elements in the arrays A1, A2, ..., and AN. B is P-by-N matrix is which P is the product of the number of elements of the N inputs. This functionality is also known as the Cartesian Product. The arguments can be numerical and/or characters, or they can be cell arrays.</p> <p>Examples:</p> <pre><code>allcomb([1 3 5],[-3 8],[0 1]) % numerical input:\n-&gt; [ 1  -3   0\n1  -3   1\n1   8   0\n...\n5  -3   1\n5   8   1 ] ; % a 12-by-3 array\n</code></pre> <pre><code>allcomb('abc','XY') % character arrays\n-&gt; [ aX ; aY ; bX ; bY ; cX ; cY] % a 6-by-2 character array\n</code></pre> <pre><code>allcomb('xy',[65 66]) % a combination\n-&gt; ['xA' ; 'xB' ; 'yA' ; 'yB'] % a 4-by-2 character array\n</code></pre> <pre><code>allcomb({'hello','Bye'},{'Joe', 10:12},{99999 []}) % all cell arrays\n-&gt; {  'hello'  'Joe'        [99999]\n'hello'  'Joe'             []\n'hello'  [1x3 double] [99999]\n'hello'  [1x3 double]      []\n'Bye'    'Joe'        [99999]\n'Bye'    'Joe'             []\n'Bye'    [1x3 double] [99999]\n'Bye'    [1x3 double]      [] } ; % a 8-by-3 cell array\n</code></pre> <p><code>ALLCOMB(..., 'matlab')</code> causes the first column to change fastest which is consistent with matlab indexing.  Example:  <pre><code>allcomb(1:2,3:4,5:6,'matlab') \n-&gt; [ 1 3 5 ; 1 4 5 ; 1 3 6 ; ... ; 2 4 6 ]\n</code></pre></p> <p>If one of the arguments is empty, ALLCOMB returns a <code>0-by-N</code> empty array.</p> <p>Tested in Matlab R2015a version 4.1 (feb 2016) (c) Jos van der Geest email: samelinoa@gmail.com</p> <p>History:</p> <p>1.1 (feb 2006), removed minor bug when entering empty cell arrays; added option to let the first input run fastest (suggestion by JD)</p> <p>1.2 (jan 2010), using ii as an index on the left-hand for the multiple output by NDGRID. Thanks to Jan Simon, for showing this little trick</p> <p>2.0 (dec 2010). Bruno Luong convinced me that an empty input should return an empty output.</p> <p>2.1 (feb 2011). A cell as input argument caused the check on the last argument (specifying the order) to crash.</p> <p>2.2 (jan 2012). removed a superfluous line of code (ischar(..))</p> <p>3.0 (may 2012) removed check for doubles so character arrays are accepted</p> <p>4.0 (feb 2014) added support for cell arrays</p> <p>4.1 (feb 2016) fixed error for cell array input with last argument being <code>matlab</code>. Thanks to Richard for pointing this out.</p> <p>See Also</p> <ul> <li>NCHOOSEK </li> <li>PERMS</li> <li>NDGRID</li> <li>NCHOOSE</li> <li>KTHCOMBN</li> </ul>"},{"location":"utils/#binnedrepr2spect","title":"binnedrepr2spect","text":"<pre><code>T = binnedrepr2spect(binned_repr, B)\nT = binnedrepr2spect(binned_repr, B, n_bins)\n</code></pre> <p>Get the stimuli spectra from a binned representation.</p> <p>ARGUMENTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude in each frequency bin for each trial.</li> <li>B: <code>1 x n_frequencies</code> vector representing the bin numbers (e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code>)</li> <li>n_bins: <code>1 x 1</code> scalar representing the number of bins if not passed as an argument, it is computed from the maximum of B</li> </ul> <p>OUTPUTS:</p> <ul> <li>T: <code>n_trials x n_frequencies</code> matrix representing the stimulus spectra</li> </ul> <p>See Also</p> <ul> <li>spect2binnedrepr</li> </ul>"},{"location":"utils/#collect_data","title":"collect_data","text":"<p>Returns the saved responses and stimuli  from reverse correlation experiments for a given config file.</p> <p>ARGUMENTS:</p> <ul> <li>config_file: <code>char</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>config: <code>struct</code>, name-value, default: <code>[]</code> An already-loaded config struct.</li> <li>data_dir: <code>char</code>, name-value, default: <code>''</code> Filepath to directory in which data is stored.  <code>config.data_dir</code> is used if left empty. </li> <li>phase: <code>1 x 1</code> positive integer, name-value, default: <code>1</code> Experiment phase from which to collect data. </li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>responses: <code>n x 1</code> numerical vector of {-1,1},  all responses associated with this config file,  where <code>n</code> is the number of trials.</li> <li>stimuli: <code>p x n</code> numerical array, of <code>config.stimuli_save_type</code>, all of the stimulus vectors associated with this config file, where <code>p</code> is the length of the stimulus vector.</li> </ul>"},{"location":"utils/#collect_data_pitch_match","title":"collect_data_pitch_match","text":"<p>Returns the saved responses and stimuli  from pitch matching experiments for a given config file.</p> <p>ARGUMENTS:</p> <ul> <li>config_file: <code>char</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>config: <code>struct</code>, name-value, default: <code>[]</code> An already-loaded config struct.</li> <li>data_dir: <code>char</code>, name-value, default: <code>''</code> Filepath to directory in which data is stored.  <code>config.data_dir</code> is used if left empty. </li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>responses: <code>n x 1</code> cell of vectors containing responses on {0,1}, where <code>n</code> is the number of PitchMatch experiments run with this config file. Each row contains the responses from separate experiments.</li> <li>stimuli: <code>n x 1</code> cell of vectors containing frequency values  corresponding to the responses.  Each row contains the responses from separate experiments.</li> <li>octave_responses: <code>n x 1</code> cell of vectors containing responses  on {0,1} to the \"octave confusion\" section of the PitchMatch experiment.  Each row contains the responses of separate experiments.</li> <li>octave_stimuli: <code>n x 1</code> cell of vectors containing frequency values from the \"octave confusion\" section of the PitchMatch experiment.  Each row contains the responses of separate experiments.</li> </ul> <p>See Also</p> <ul> <li>PitchMatch</li> <li>get_best_pitch</li> </ul>"},{"location":"utils/#collect_data_thresh_or_loud","title":"collect_data_thresh_or_loud","text":"<p>Returns the saved dB levels and corresponding tones from either threshold determination or loudness matching experiments for a given config file.</p> <p>ARGUMENTS:</p> <ul> <li>exp_type: <code>char</code>, valid values: 'threshold' or 'loudness', the type of experimental data to collect.</li> <li>config_file: <code>char</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>config: <code>struct</code>, name-value, default: <code>[]</code> An already-loaded config struct.</li> <li>data_dir: <code>char</code>, name-value, default: <code>''</code> Filepath to directory in which data is stored.  <code>config.data_dir</code> is used if left empty. </li> <li>average: <code>logical</code>, name-value, default: <code>true</code>, Flag to average dB values for all repeated tones.</li> <li>fill_nans: <code>logical</code>, name-value, default: <code>false</code>, Flag to fill in NaN values with the previous non-NaN value</li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>pres_dBs: <code>n x 1</code> vector containing dB values, where <code>n</code> is the number of unique tones if <code>average</code> is <code>true</code>, or is the number of presented stimuli if <code>average</code> is `false.</li> <li>amp_dBs: <code>n x 1</code> vector containing amplitude values.</li> <li>tones: <code>n x 1</code> vector containing frequency values for each response.</li> </ul>"},{"location":"utils/#collect_parameters","title":"collect_parameters","text":"<p>Read parameters out from character vectors of text contained in a character vector or cell array.</p> <p>ARGUMENTS:</p> <ul> <li>filenames: <code>cell array</code> of character vectors or <code>character vector</code> that contains the filenames (or text strings) out of which to read parameters.</li> </ul> <p>If <code>filenames</code> is a cell array, parameters are read from each character vector contained in the cell array. Filenames should not have file endings like <code>'.csv'</code>. The regular expressions are not sophisticated enough to skip them.</p> <p>OUTPUTS:</p> <ul> <li>data_table: <code>table</code></li> </ul> <p>Example:</p> <pre><code>data_table = collect_parameters(filenames)\n</code></pre> <p>See Also</p> <ul> <li>collect_reconstructions</li> <li>collect_data</li> <li>config2table</li> </ul>"},{"location":"utils/#collect_reconstructions","title":"collect_reconstructions","text":"<p>Collect reconstructions (or other data) from <code>.csv</code> files following a naming convention. Returns a matrix of all the data.</p> <p>While this function was intended to read reconstructions, it should be able to return data from any <code>.csv</code> files containing data that can be represented in a MATLAB matrix (e.g., numerical data of the same length).</p> <p>ARGUMENTS:</p> <ul> <li>data_struct: struct vector or character vector A struct containing the output of a call to <code>dir()</code> indicating which files to extract from or a character vector which is used as an argument for <code>dir()</code> (e.g., <code>dir(data_struct)</code>). The regular expression is used to filter the data struct based on the filenames.</li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>reconstructions: numerical matrix <code>m x n</code> matrix that contains the numerical data, where <code>m</code> is the length of the data and <code>n</code> is the number of files.</p> </li> <li> <p>reconstruction_files: cell array of character vectors Contains the filepaths to each file read, corresponding to the columns of <code>reconstructions</code>.</p> </li> </ul> <p>See Also</p> <ul> <li>collect_data</li> <li>dir</li> </ul>"},{"location":"utils/#config2table","title":"config2table","text":"<p>Take information from directory containing config files and return a table with all relevant information for each config.</p> <p>ARGUMENTS: </p> <ul> <li> <p>curr_dir: <code>struct</code>,  which is the directory information  containing config file name, path, and other returns from <code>dir()</code> function.</p> </li> <li> <p>variables_to_remove: <code>cell</code>, default: <code>{}</code>, a cell array of character vectors, indicating which variables (columns) of the data table to remove. If empty, re-defaults to: <code>{'n_trials_per_block', 'n_blocks', ... 'min_freq', 'max_freq', 'duration', 'n_bins', ... 'target_signal_filepath', 'bin_target_signal', ... 'data_dir', 'stimuli_save_type'}</code>.</p> </li> </ul> <p>OUTPUTS: </p> <ul> <li>data_table: <code>table</code></li> </ul> <p>See Also</p> <ul> <li>parse_config</li> <li>dir</li> </ul>"},{"location":"utils/#create_files_and_stimuli","title":"create_files_and_stimuli","text":"<p>Create files for the stimuli, responses, and metadata and create the stimuli. Write the stimuli into the stimuli file.</p> <p>ARGUMENTS:</p> <ul> <li>config: <code>1 x 1</code> struct, the config struct to associate the files with.</li> <li>stimuli_object: <code>1 x 1</code> AbstractStimulusGenerationMethod,  a StimulusGeneration object from which stimuli will be generated.</li> <li>hash_prefix: <code>char</code>, default: <code>''</code>, the portion of the hash attached to the output files  that appears before the spectrum matrix hash.</li> </ul> <p>OUTPUTS:</p> <ul> <li>stimuli_matrix: <code>n x p</code> numerical array, stimulus waveforms where <code>n</code> is the length of the waveform and <code>p</code> is <code>config.n_trials</code></li> <li>Fs: <code>1 x 1</code> positive scalar, the sampling rate in Hz</li> <li>filename_responses: <code>char</code> the full path to the empty <code>CSV</code> file  in which responses can be written for this experiment.</li> <li>filename_stimuli: <code>char</code> the full path to the <code>CSV</code> file  in which the stimuli are written according to <code>config.stimuli_save_type</code>.</li> <li>filename_meta: <code>char</code> the full path to the empty <code>CSV</code> file in which the metadata can be written for this experiment.</li> <li>file_hash: <code>char</code> the full hash string associated with all the output files.</li> </ul> <p>See Also</p> <ul> <li>RevCorr</li> </ul>"},{"location":"utils/#create_files_and_stimuli_2afc","title":"create_files_and_stimuli_2afc","text":"<p>Create files for the stimuli, responses, and metadata and create the stimuli for a 2-AFC experiment. Write the stimuli into the stimuli file.</p> <p>Arguments:</p> <ul> <li>config: 1x1 <code>struct</code>  containing a stimulus generation configuration.</li> <li>stimuli_object: 1x1 <code>AbstractStimulusGenerationMethod</code></li> <li>hash_prefix: 1 x n character vector, default value: <code>get_hash(config)</code></li> </ul> <p>Outputs:</p> <ul> <li>stimuli_matrix_1</li> <li>stimuli_matrix_2</li> <li>Fs</li> <li>filename_responses</li> <li>filename_stimuli_1</li> <li>filename_stimuli_2</li> <li>filename_meta</li> <li>file_hash_1</li> <li>file_hash_2</li> <li>file_hash_combined</li> </ul> <p>Example:</p> <pre><code>[stimuli_matrix_1, stimuli_matrix_2, Fs, filename_responses, filename_stimuli_1, filename_stimuli_2, filename_meta, file_hash_1, file_hash_2, file_hash_combined] = create_files_and_stimuli_2afc(config, stimuli_object, hash_prefix)\n</code></pre> <p>See Also</p> <ul> <li>RevCorr</li> </ul>"},{"location":"utils/#create_files_and_stimuli_phasen","title":"create_files_and_stimuli_phaseN","text":"<p>For RevCorr_phaseN experiments,  create files for the stimuli, responses, and metadata and create the stimuli. Write the stimuli into the stimuli file.</p> <p>Stimuli are generated by applying random noise and other modifiers  to the phase 1 reconstruction.</p> <p>ARGUMENTS:</p> <ul> <li>config: <code>1 x 1</code> struct, the config struct to associate the files with.</li> <li>phase: <code>1 x 1</code> integer &gt; 1, the current phase of experiment.  Practically, this indicates which phase's reconstruction to perturb from (<code>phase</code> - 1).</li> <li>pert_bounds: <code>1 x 2</code> vector of positive values,  the min and max factor to perturb by. Ex: <code>[0.5, 1.5]</code> will range  from half to 1.5x the magnitude of the reconstruction values. </li> <li>data_dir: <code>char</code>, the directory in which phase (<code>phase</code> - 1)  stimuli-response pairs can be found </li> <li>hash_prefix: <code>char</code>, default: <code>''</code>, the hash prefix associated with the  phase (<code>phase</code> - 1) stimuli-response pairs</li> <li>reconstruction: <code>n x 1</code> numerical vector, default: <code>[]</code>, the reconstruction from which to generate stimuli. Overrides generating from config if not empty.</li> <li>mult_range: <code>n x m</code> numerical array,  the min and max values possible for the mult parameter in <code>binnedrepr2wav</code>. Array can technically be any size, but only min and max are used.</li> <li>binrange_range: <code>n x m</code> positive numerical array,  the min and max values possible for the binrange parameter in <code>binnedrepr2wav</code>. Array can technically be any size, but only min and max are used.</li> <li>lowcut_range: <code>n x m</code> numerical array &gt;= 0,  the min and max values possible for the low cutoff frequency in <code>binnedrepr2wav</code>. Array can technically be any size, but only min and max are used.</li> <li>highcut_range: <code>n x m</code> positive numerical array,  the min and max values possible for the low cutoff frequency in <code>binnedrepr2wav</code>. Array can technically be any size, but only min and max are used.</li> </ul> <p>OUTPUTS:</p> <ul> <li>stimuli_matrix: <code>n x p</code> numerical array, stimulus waveforms where <code>n</code> is the length of the waveform and <code>p</code> is <code>config.n_trials</code></li> <li>Fs: <code>1 x 1</code> positive scalar, the sampling rate in Hz</li> <li>filename_responses: <code>char</code> the full path to the empty <code>CSV</code> file  in which responses can be written for this experiment.</li> <li>filename_stimuli: <code>char</code> the full path to the <code>CSV</code> file  in which the stimuli are written according to <code>config.stimuli_save_type</code>.</li> <li>filename_meta: <code>char</code> the full path to the empty <code>CSV</code> file in which the metadata can be written for this experiment.</li> <li>file_hash: <code>char</code> the full hash string associated with all the output files.</li> </ul> <p>See Also</p> <ul> <li>RevCorr_phaseN</li> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2wav</li> </ul>"},{"location":"utils/#crossval_irwlsq","title":"crossval_irwlsq","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using iteratively reweighted least squares.</p> <pre><code>[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_irwlsq(folds, thresh, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_irwlsq(folds, thresh, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>thresh: <code>1 x p</code> numerical vector or <code>scalar</code>,  representing the threshold value in the estimate to response conversion: <code>sign(X*b + threshold)</code>. If there are multiple values, it will be optimized in the development section.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>weight_func: <code>char</code>, name-value, default: <code>'bisquare'</code>, The weight function to use. See <code>RobustOpts</code> argument in <code>fitlm</code> docs for valid options. </li> <li>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, flag to set the mean of the stimuli to zero when computing the reconstruction and both the mean of the stimuli and the reconstruction to zero when generating the predictions.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> <li>pred_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data.</li> <li>true_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data. the original subject responses in the order corresponding  to the predicted responses on the training data.</li> </ul>"},{"location":"utils/#crossval_knn","title":"crossval_knn","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using K-Nearest Neighbors.</p> <pre><code>[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_knn(folds, k, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_knn(folds, k, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>k: <code>1 x p</code> numerical vector or <code>scalar</code>, number of nearest neighbors to consider. If there are multiple values,  it will be optimized in the development section.</li> <li>method: <code>char</code>, name-value, default: 'mode', class determination style to be passed to knn function.</li> <li>percent: <code>scalar</code>, name-value, default: 75, Target percent passed to knn function if <code>knn_method</code> is 'percent'.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>norm_stim: <code>bool</code>, name-value, default: <code>false</code>, flag to normalize the stimuli after loading.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> <li>pred_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data.</li> <li>true_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data. the original subject responses in the order corresponding  to the predicted responses on the training data,</li> </ul>"},{"location":"utils/#crossval_lda","title":"crossval_lda","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using linear discriminant analysis.</p> <pre><code>[pred_resps, true_resps] = crossval_lda(folds, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps] = crossval_lda(folds, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> </ul> <p>See Also</p> <ul> <li>fitcdiscr</li> </ul>"},{"location":"utils/#crossval_lwlr","title":"crossval_lwlr","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using locally weighted linear regression.</p> <pre><code>[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_lwlr(folds, h, thresh, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_lwlr(folds, h, thresh, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>h: <code>1 x p</code> numerical vector or <code>scalar</code>, representing the width parameter(s) for the Gaussian kernel. If there are multiple values,  it will be optimized in the development section.</li> <li>thresh: <code>1 x q</code> numerical vector or <code>scalar</code>,  representing the threshold value in the estimate to response conversion: <code>sign(X*b + threshold)</code>. If there are multiple values, it will be optimized in the development section.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>norm_stim: <code>bool</code>, name-value, default: <code>false</code>, flag to normalize the stimuli after loading.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> <li>pred_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data.</li> <li>true_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data. the original subject responses in the order corresponding  to the predicted responses on the training data,</li> </ul>"},{"location":"utils/#crossval_pnr","title":"crossval_pnr","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using polynomial regression.</p> <pre><code>[pred_resps, true_resps] = crossval_pnr(folds, ords, thresh, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps] = crossval_pnr(folds, ords, thresh, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>ords: <code>1 x p</code> numerical vector or <code>scalar</code>, representing the polynomial order(s) on which to perform regression. If there are multiple values,  it will be optimized in the development section.</li> <li>thresh: <code>1 x q</code> numerical vector or <code>scalar</code>, representing the percentile threshold value(s). If there are multiple values,  it will be optimized in the development section. Values must be on (0,100].</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>norm_stimuli: <code>bool</code>, name-value, default: <code>false</code>, flag to normalize the stimuli after loading.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> </ul> <p>See Also</p> <ul> <li>polyfitn</li> </ul>"},{"location":"utils/#crossval_predicted_responses","title":"crossval_predicted_responses","text":"<p>Generate response predictions for a given  config file or pair of stimuli and responses using stratified cross validation and either the subject response model.</p> <pre><code>[given_resps, training_resps, on_test, on_train] = crossval_predicted_responses(folds, 'config', config, 'data_dir', data_dir)\n[given_resps, training_resps, on_test, on_train] = crossval_predicted_responses(folds, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>normalize: <code>bool</code>, name-value, default: <code>false</code>, flag to normalize the stimuli after loading.</li> <li>gamma: <code>1 x 1</code> scalar, name-value, default: <code>8</code>,</li> <li>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, flag to set the mean of the stimuli to zero when computing the reconstruction and both the mean of the stimuli and the reconstruction to zero when generating the predictions.</li> <li>from_responses: <code>bool</code>, name-value, default: <code>false</code>, flag to determine the threshold from the given responses.  Overwrites <code>threshold_values</code> and does not run threshold development cycle.</li> <li>ridge_reg: <code>bool</code>, name-value, default: <code>false</code>, flag to use ridge regression instead of standard linear regression for reconstruction.</li> <li>threshold_values: <code>1 x m</code> numerical vector, name-value, default: <code>linspace(10,90,200)</code>, representing the percentile threshold values on which to perform development to identify optimum.  Values must be on (0,100]. representing the gamma value to use in  compressed sensing reconstructions if <code>config</code> is empty.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.       </li> </ul> <p>OUTPUTS:</p> <ul> <li>given_resps: <code>p x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector. <code>p</code> is the number of original responses.</li> <li>training_resps: <code>(folds-2)*p x 1</code> vector, the original subject responses used in the training phase. The training data is partially repeated between folds.</li> <li>on_test: <code>struct</code> with <code>p x 1</code> vectors in fields <code>cs</code>, <code>lr</code>, predicted responses on testing data.</li> <li>on_train: <code>struct</code> with <code>(folds-2)*p x 1</code> vectors in fields <code>cs</code>, <code>lr</code> predicted responses on training data.</li> </ul> <p>See Also</p> <ul> <li>subject_selection_process</li> </ul>"},{"location":"utils/#crossval_rc","title":"crossval_rc","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using the classical reverse correlation model  y = sign(Psi * x) or y = sign(Psi * x + thresh).</p> <pre><code>[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_rc(folds, thresh, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_rc(folds, thresh, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>thresh: <code>1 x p</code> numerical vector or <code>scalar</code>,  representing the threshold value in the estimate to response conversion: <code>sign(X*b + threshold)</code>. If there are multiple values, it will be optimized in the development section.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>ridge: <code>bool</code>, name-value, default: <code>false</code>, flag to use ridge regression instead of standard linear regression for reconstruction.</li> <li>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, flag to set the mean of the stimuli to zero when computing the reconstruction and both the mean of the stimuli and the reconstruction to zero when generating the predictions.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> <li>pred_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data.</li> <li>true_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data. the original subject responses in the order corresponding  to the predicted responses on the training data.</li> <li>pred_cont_test: <code>n x 1</code> vector, The inner product values on testing data before quantization.</li> </ul>"},{"location":"utils/#crossval_rc_adjusted","title":"crossval_rc_adjusted","text":"<p>Generate the cross-validated response predictions for a given config file using the upsampled and peak sharpened representation in bin form. Config file must have an associated survey with mult and binrange values. Reconstruction methods can be the classical reverse correlation model y = sign(Psi * x) or y = sign(Psi * x + thresh).</p> <pre><code>[pred_resps, true_resps, pred_resps_train, true_resps_train] = crossval_rc_adjusted(folds, thresh, 'config', config, 'data_dir', data_dir)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</li> <li>thresh: <code>1 x p</code> numerical vector or <code>scalar</code>, representing the threshold value in the estimate to response conversion: <code>sign(X*b + threshold)</code>. If there are multiple values, it will be optimized in the development section.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the config structis stored.</li> <li>ridge: <code>bool</code>, name-value, default: <code>false</code>, flag to use ridge regression instead of standard linear regression for reconstruction.</li> <li>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, flag to set the mean of the stimuli to zero when computing the reconstruction and both the mean of the stimuli and the reconstruction to zero when generating the predictions.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding to the predicted responses, i.e., a shifted version of the original response vector.</li> <li>pred_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data.</li> <li>true_resps_train: <code>folds*(n-round(n/folds)) x 1</code> vector, OR <code>folds*(2*(n-round(n/folds))) x 1</code> vector if dev is run. the predicted responses on the training data. the original subject responses in the order corresponding to the predicted responses on the training data,</li> </ul>"},{"location":"utils/#crossval_svm","title":"crossval_svm","text":"<p>Generate the cross-validated response predictions for a given  config file or pair of stimuli and responses using support vector machines.</p> <pre><code>[pred_resps, true_resps] = crossval_svm(folds, 'config', config, 'data_dir', data_dir)\n[pred_resps, true_resps] = crossval_svm(folds, 'responses', responses, 'stimuli', stimuli)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete.</li> <li>config: <code>struct</code>, name-value, deafult: <code>[]</code> config struct from which to find responses and stimuli</li> <li>data_dir: <code>char</code>, name-value, deafult: <code>''</code> the path to directory in which the data corresponding to the  config structis stored.</li> <li>responses: <code>n x 1</code> array, name-value, default: <code>[]</code> responses to use in reconstruction,  where <code>n</code> is the number of responses. Only used if passed with <code>stimuli</code>.</li> <li>stimuli: <code>m x n</code> array, name-value, default: <code>[]</code> stimuli to use in reconstruction, where <code>m</code> is the number of bins. Only used if passed with <code>responses</code>.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.    </li> </ul> <p>OUTPUTS:</p> <ul> <li>pred_resps: <code>n x 1</code> vector, the predicted responses.</li> <li>true_resps: <code>n x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector.</li> </ul> <p>See Also</p> <ul> <li>fitclinear</li> </ul>"},{"location":"utils/#cs","title":"cs","text":"<pre><code>[x] = cs(responses, Phi, Gamma)\n[x] = cs(responses, Phi)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>responses: <code>n x 1</code> vector</p> </li> <li> <p>Phi: <code>n x m</code> matrix, where <code>n</code> is the number of trials/samples and <code>m</code> is the dimensionality of the stimuli/spectrum/bins</p> </li> <li> <p>Gamma: Positive scalar, default: 32 optional value for zhangpassivegamma function.</p> </li> <li> <p>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, a flag for setting the mean of <code>Phi</code> to zero.</p> </li> <li> <p>verbose: <code>bool</code>, name-value, default: <code>true</code>, a flag to print information messages</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>x: <code>m x 1</code> vector, representing the compressed sensing reconstruction of the signal.</li> </ul> <p>See Also</p> <ul> <li>cs_no_basis</li> </ul>"},{"location":"utils/#disp_fullscreen","title":"disp_fullscreen","text":"<p>Expand current figure to full screen and fill with an image.</p> <p>ARGUMENTS:</p> <ul> <li>img: <code>n x m x 3</code> array representing an  image. Typically loaded via imread().</li> <li>hFig: handle to figure.  Defaults to current figure.</li> </ul> <p>OUTPUTS:</p> <ul> <li>hFig now displays an image.</li> </ul>"},{"location":"utils/#filematch","title":"filematch","text":"<p>Match files by terminal UUID or other identifier. This function expects filenames in the form</p> <p><code>foo_bar_UUID.baz</code></p> <p>Where foo_bar can be anything, so long as the UUID or other identifier comes last before the 'dot filetype'. The functions returns indices of unmatched files.</p> <p>Example:</p> <p><code>filematch(files1, files2)</code></p> <p>See Also</p> <ul> <li>collect_data</li> </ul>"},{"location":"utils/#gen_octaves","title":"gen_octaves","text":"<p>Returns a vector of doubled values from  min_freq to as close to max_freq as possible  with optional, equally spaced in-octave values.</p> <p>ARGUMENTS:</p> <ul> <li>min_freq: <code>1 x 1</code> scalar, the minimum and initial frequency</li> <li>max_freq: <code>1 x 1</code> scalar, the maximum possible frequency,  not guaranteed to be in the final array.</li> <li>n_in_oct: <code>1 x 1</code> integer, the number of points inside each octave. If <code>spacing_type</code> == <code>'semitone'</code>,  <code>n_in_oct</code> must be in {1,2,3,5,11}.  Otherwise, can be any integer &gt;= 0.</li> <li>spacing_type: <code>char</code>, default: <code>'semitone'</code>,  the in-octave spacing method.  <code>'linear'</code> returns linearly spaced spaced values <code>'semitone'</code> splits the octave into half notes  then chooses <code>n_in_oct</code> evenly spaced values.</li> </ul> <p>OUTPUTS:</p> <ul> <li>freqs: <code>n x 1</code> numerical vector of octaves starting at <code>min_freq</code>.</li> </ul>"},{"location":"utils/#get_accuracy_measures","title":"get_accuracy_measures","text":"<p>Computes standard accuracy measures between true and predicted labels. Values greater than or equal to 1 are considered positives, and values less than 1 are considered negative.</p> <p>ARGUMENTS:</p> <ul> <li>y: <code>m x p</code> numerical matrix, representing true labels.</li> <li>y_hat: <code>m x n</code> numerical matrix, representing predicted labels.</li> </ul> <p>OUTPUTS:</p> <ul> <li>accuracy: <code>scalar</code> or <code>1 x max(n,p)</code> vector, the correct prediction rate. </li> <li>balanced_accuracy: <code>scalar</code> or <code>1 x max(n,p)</code> vector, the average of <code>sensitivity</code> and <code>specificity</code>.</li> <li>sensitivity: <code>scalar</code> or <code>1 x max(n,p)</code> vector, the true positive rate.</li> <li>specificity: <code>scalar</code> or <code>1 x max(n,p)</code> vector, the true negative rate.</li> </ul>"},{"location":"utils/#get_best_pitch","title":"get_best_pitch","text":"<p>Returns the matched pitch for a given config's PM data  and whether or not all any octaves were confused</p> <p>ARGUMENTS:</p> <ul> <li>config_file: <code>character vector</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>config: <code>struct</code>, name-value, default: <code>[]</code>, the loaded config.</li> <li>data_dir: <code>character vector</code>, name-value, default: <code>''</code>, the path to the location of the data.  If none is supplied, config.data_dir will be used.</li> <li>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information text.</li> </ul> <p>OUTPUTS:</p> <ul> <li>best_freq: <code>1x1</code> scalar, the identified best frequency.</li> <li>oct_agree: <code>bool</code>, <code>true</code> if there was never any octave confusion over all data <code>false</code> if there was ever any octave confusion.</li> </ul> <p>See Also</p> <ul> <li>PitchMatch</li> <li>collect_data_pitch_match</li> </ul>"},{"location":"utils/#get_gamma_from_config","title":"get_gamma_from_config","text":"<p>Choose a gamma value to be used in <code>cs</code> based on data in the config.</p> <p>ARGUMENTS:</p> <ul> <li>config: <code>struct</code>, config from which to find gamma</li> <li>verbose: <code>bool</code>, default: <code>true</code>, flag to print information messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>this_gamma: <code>scalar</code>, the chosen gamma value.</li> </ul>"},{"location":"utils/#get_highest_power_of_2","title":"get_highest_power_of_2","text":"<p>Compute the highest power of two less than or equal to a number. For example, an input of 9 would return 8.</p> <p>EXAMPLE:</p> <pre><code>n = get_highest_power_of_2(N);\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>N: a 1x1 scalar, positive, real integer</li> </ul> <p>OUTPUTS:</p> <ul> <li>n: a 1x1 scalar, positive, real power of 2</li> </ul>"},{"location":"utils/#get_reconstruction","title":"get_reconstruction","text":"<p>Compute reconstructions using data specified by a configuration file.</p> <pre><code>[x, responses_output, stimuli_matrix_output] = get_reconstruction('key', value, ...)\nx = get_reconstruction('config_file', 'path_to_config', 'preprocessing', {'bit_flip'}, 'method', 'cs', 'verbose', true)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>config_file: string or character array, name-value, default: <code>''</code> A path to a YAML-spec configuration file. Either this argument or <code>config</code> is required.</li> <li>config: struct, name-value, default: <code>[]</code> A configuration file struct (e.g., one created by <code>parse_config</code>).</li> <li>preprocessing: cell array of character vectors, name-value, default: <code>{}</code> A list of preprocessing steps to take. Currently, the only supported preprocessing step is <code>'bit flip'</code>, which flips the sign on all responses before computing the reconstruction.</li> <li>method: character vector, name-value, default: <code>'cs'</code> Which reconstruction algorithm to use.  Options: <code>'cs'</code>, <code>'cs_nb'</code>, <code>'linear'`,</code>'linear_ridge'``.</li> <li>use_n_trials: Positive scalar, name-value, default: <code>inf</code> Indicates how many trials to use of data. <code>inf</code> uses all data.</li> <li>bootstrap: Positive scalar, name-value, deafult: 0 Number of bootstrap iterations to perform.</li> </ul> <p>See Also</p> <ul> <li>collect_reconstructions</li> <li>collect_data</li> <li>config2table</li> </ul>"},{"location":"utils/#gs","title":"gs","text":"<p>Returns the linear reconstruction of stimuli and responses.</p> <pre><code>x = gs(responses, Phi)\nx = gs(responses, Phi, 'ridge', true, 'mean_zero', true)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>responses: <code>n x 1</code> vector of 1 and -1 values, representing the subject's responses.</p> </li> <li> <p>Phi: <code>n x m</code> numerical matrix, where m is the length of each stimulus  and n is the same length as the responses</p> </li> <li> <p>ridge: <code>boolean</code>, name-value, default: <code>false</code>, a flag to for using ridge regression.</p> </li> <li> <p>mean_zero: <code>boolean</code>, name-value, defaut: <code>false</code>, a flag for setting the mean of <code>Phi</code> to zero.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>x: <code>m x 1</code> vector, representing the linear reconstruction of the signal,  where m is the length of a stimulus. </li> </ul>"},{"location":"utils/#knn_classify","title":"knn_classify","text":"<p>Returns the estimated class labels for a matrix of  reference points T, given data points X and labels y.</p> <p>ARGUMENTS:</p> <ul> <li>y: <code>n x 1</code> vector, representing class labels that correspond to data points in <code>X</code>.</li> <li>X: <code>n x p</code> numerical matrix, labelled data points.</li> <li>T: <code>m x p</code> numerical matrix, representing reference points without/needing class labels</li> <li>k: <code>scalar</code>, indicating the number of nearest neighbors to be considered.</li> <li>method: <code>char</code>, name-value, default: 'mode', method by which to determine the class label. Valid methods are 'mode', which takes the most common neighbor label 'min_class', which takes the least common,  and 'percent', which takes the class with the closest percent occurrance.</li> <li>percent: <code>scalar</code>, name-value, default: 75, if method is 'percent', label is assigned based on the class with  the closest percent occurrance to this argument.</li> </ul> <p>OUTPUTS:</p> <ul> <li>z_hat: <code>m x 1</code> vector, estimated class labels for data points in T.</li> </ul>"},{"location":"utils/#munge_hashes","title":"munge_hashes","text":"<p>Processes config files, correcting errors. Then, fixes the hashes for saved data files associated with changed config files.</p> <pre><code>munge_hashes(\"file_string\", \"config*.yaml\", \"verbose\", true)\n</code></pre> <p>Arguments:</p> <ul> <li> <p>file_string: <code>string</code> or <code>character vector</code>, name-value, default: <code>\"config*.yaml\"</code> A file pattern, optionally using globs that is passed to <code>dir</code> to search for configuration files to munge.</p> </li> <li> <p>legacy_flag: <code>logical scalar</code>, name-value, default: <code>false</code> Whether to load config files in \"legacy mode\", e.g., with <code>ReadYaml</code> instead of <code>yaml.loadFile</code>.</p> </li> <li> <p>verbose: <code>logical scalar</code>, name-value, default: <code>true</code> Whether to print informative text.</p> </li> <li> <p>data_dir: <code>string</code> or <code>character vector</code>, name-value, default: <code>\".\"</code> Path to the directory where the data files to-be-munged are.</p> </li> </ul> <p>See Also</p> <ul> <li>update_hashes</li> </ul>"},{"location":"utils/#p","title":"P","text":"<p>Soft threshold operator used in compressed sensing</p>"},{"location":"utils/#parse_config","title":"parse_config","text":"<p>Read a config file and perform any special parsing that is required.</p> <p>ARGUMENTS:</p> <ul> <li>config_file: character vector, default: [] Path to the config file to be used. If empty, opens a GUI to find the file using a file browser.</li> <li>legacy: <code>logical</code>, name-value, default: <code>false</code>, flag to indicate use of legacy <code>ReadYaml</code> package. </li> <li>verbose: <code>logical</code>, name-value, default: <code>true</code>, flag to show informational messages.</li> </ul> <p>OUTPUTS:</p> <ul> <li>config: <code>struct</code>, the parsed config file.</li> <li>config_file: <code>char</code>,  the provided path or else the full path chosen from GUI.</li> </ul> <p>See Also</p> <ul> <li>yaml.loadFile</li> </ul>"},{"location":"utils/#parse_rand_nbins","title":"parse_rand_nbins","text":"<p>Parses stimuli and responses into cells  based on number of bins in the stimuli For use with UniformPriorRandNBinsStimulusGeneration stimuli</p> <p>ARGUMENTS:</p> <ul> <li>responses: <code>n x 1</code> numerical array, response data,  where <code>n</code> is the number of completed trials.</li> <li>stimuli: <code>m x n</code>, the stimuli data, where <code>m</code> is the max number of bins</li> </ul> <p>OUTPUTS:</p> <ul> <li>resp_cell: <code>p x 1</code> cell, where <code>p</code> is the number of unique bins. Responses organized into arrays within the cell.</li> <li>stim_cell: <code>p x 1</code> cell, the corresponding stimuli to  <code>resp_cell</code> in increasing bin order.</li> </ul> <p>See Also</p> <ul> <li>UniformPriorRandNBinsStimulusGeneration.generate_stimuli_matrix</li> </ul>"},{"location":"utils/#play_calibration_sound","title":"play_calibration_sound","text":"<p>Plays a 1000 Hz tone at system volume with a sample rate of 44100 Hz. No arguments.</p>"},{"location":"utils/#prop2str","title":"prop2str","text":"<pre><code>stringified_properties = prop2str(obj, [], '&amp;&amp;')\n</code></pre> <p>Converts the property names and values of a struct or object into a character vector. For example, a struct, s, with the properties, s.a = 1, s.b = 2, would become 'a=1-b=2'. If some of the property values are cell arrays, they should be character vectors or numerical vectors and of the same type within each cell array.</p> <p>ARGUMENTS:</p> <ul> <li> <p>obj: <code>1 x 1</code> struct or object, the object with properties to be stringified</p> </li> <li> <p>properties_to_skip: character vector or cell array Properties to not include in the output character vector.</p> </li> <li> <p>property_separator: character vector What separator to use between parameter statements.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>stringified_properties: character vector</li> </ul> <p>See Also</p> <ul> <li>collect_parameters</li> </ul>"},{"location":"utils/#pure_tone","title":"pure_tone","text":"<p>Generate a sinusoidal pure tone stimuli</p> <p>ARGUMENTS:</p> <ul> <li>tone_freq: <code>1 x 1</code> positive scalar, the frequency to play</li> <li>dur: <code>1 x 1</code> positive scalar,  the duration of the sound in seconds, default: 0.5  </li> <li>Fs: <code>1 x 1</code> positive scalar,  the sample rate of the sound in Hz, deafult: 44100</li> </ul> <p>OUTPUTS:</p> <ul> <li>stim: <code>1 x n</code> numerical vector, the sinusoidal waveform</li> </ul>"},{"location":"utils/#r_viz","title":"r_viz","text":"<p>Plots bar charts of r values from table data.  A separate figure is made for each subject.</p> <p>ARGUMENTS:</p> <ul> <li>T: <code>table</code> that includes r values of interest</li> </ul> <p>OUTPUTS:</p> <ul> <li>n figures, where n is the number of subjects included in the table.</li> </ul> <p>See Also</p> <ul> <li>pilot_reconstructions</li> </ul>"},{"location":"utils/#rand_str","title":"rand_str","text":"<p>Generates a random string of length <code>len</code> with numbers 0-9 and letters Aa-Zz</p> <p>ARGUMENTS:</p> <ul> <li>len: <code>1 x 1</code> positive integer, default: <code>8</code> the length of the string</li> </ul> <p>OUTPUTS:</p> <ul> <li>str: <code>1 x len</code> random character vector</li> </ul>"},{"location":"utils/#semitones","title":"semitones","text":"<p>Returns one octave of semitones from the initial frequency, includes both octave endpoints.</p> <p>ARGUMENTS:</p> <ul> <li>init_freq: <code>1 x 1</code> scalar, the initial frequency.</li> <li>n: <code>1 x 1</code> positive integer, default: <code>12</code>, the number of semitones above init_freq to to return.</li> <li>direction: <code>char</code>, default: <code>'up'</code>, options: <code>'up'</code>, <code>'down'</code>. direction in which to generate semitones from <code>init_freq</code>.</li> </ul> <p>OUTPUTS:</p> <ul> <li>tones: <code>n+1 x 1</code> numerical vector,  <code>n+1</code> semitones starting at <code>init_freq</code>.</li> </ul>"},{"location":"utils/#spect2binnedrepr","title":"spect2binnedrepr","text":"<p>binned_repr = spect2binnedrepr(T, B) binned_repr = spect2binnedrepr(T, B, n_bins)</p> <p>Get the binned representation, which is a vector containing the amplitude of the spectrum in each frequency bin.</p> <p>ARGUMENTS:</p> <ul> <li> <p>T: <code>n_trials x n_frequencies</code> matrix representing the stimulus spectra</p> </li> <li> <p>B: <code>1 x n_frequencies</code> vector representing the bin numbers (e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code>)</p> </li> <li> <p>n_bins: <code>1x1</code> scalar representing the number of bins if not passed as an argument, it is computed from the maximum of B</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude for each frequency bin for each trial</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> </ul>"},{"location":"utils/#str2prop","title":"str2prop","text":"<p>Converts a string of properties and values into a struct or cell array. TODO: more documentation, use property_separator</p> <p>ARGUMENTS:</p> <ul> <li> <p>prop_string: character vector String containing property : value pairs</p> </li> <li> <p>properties_to_skip: character vector or cell array Properties to not incude in the output character vector</p> </li> <li> <p>property_separator: character vector What separator to use between parameter statements.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>obj: struct or cell array</li> </ul> <p>Example: <pre><code>obj = str2prop(prop_string, [], '&amp;&amp;')\n</code></pre></p> <p>See Also</p> <ul> <li>collect_parameters</li> </ul>"},{"location":"utils/#subject_selection_process","title":"subject_selection_process","text":"<p>Returns a response vector and the stimuli where the response vector is made of up -1 and 1 values corresponding to yes and no statements about how well the stimuli correspond to the representation.</p> <pre><code>[y, X] = subject_selection_process(representation, stimuli)\n[y, X] = subject_selection_process(representation, stimuli, [], responses, 'mean_zero', true, 'from_responses', true)\n[y, X] = subject_selection_process(representation, stimuli, 'method', 'sign', 'lambda', 0.5)\n[y, X] = subject_selection_process(representation, stimuli, [], [], 'threshold', 90, 'verbose', false)\n[y, X] = subject_selection_process(representation, [], n_samples)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>representation: <code>n x 1</code> numerical vector, the signal to compare against (e.g., the tinnitus signal).</p> </li> <li> <p>stimuli: numerical matrix, an <code>m x n</code> matrix where m is the number of samples/trials and n is the same length as the representation. If stimuli is empty, a random Bernoulli matrix (p = 0.5) is used.</p> </li> <li> <p>n_samples: integer scalar representing how many samples are used when generating the Bernoulli matrix default for stimuli, if the stimuli argument is empty.</p> </li> <li> <p>responses: <code>m x 1</code> numerical vector,  which contains only <code>-1</code> and <code>1</code> values, used to determine the threshold if using one of the custom options.</p> </li> <li> <p>mean_zero: <code>bool</code>, name-value, default: <code>false</code>,  representing a flag that centers the mean of the stimuli and representation.</p> </li> <li> <p>method: <code>character vector</code>, name-value, default: <code>percentile</code>, the method to use to convert estimations into response values. Options are: <code>percentile</code>, which uses the whole estimation vector and <code>threshold</code>, <code>sign</code> which computes <code>sign(e + lambda)</code>, and <code>ten_scale</code>, which returns values from 0-10 using.</p> </li> <li> <p>from_responses: <code>bool</code>, name-value, default: <code>false</code>, a flag to determine the threshold from the given responses.  The default results in 50% threshold.  If using this option, <code>responses</code> must be passed as well.</p> </li> <li> <p>threshold: Positive scalar, name-value, default: 50, representing the percent of -1 responses in <code>y</code>. If <code>from_responses</code> is true, this will be ignored.</p> </li> <li> <p>lambda: Scalar &gt;= 0, name-value, default: 0, value for use in <code>sign(e + lambda)</code> if <code>method</code> is <code>sign</code>.</p> </li> <li> <p>verbose: <code>bool</code>, name-value, default: <code>true</code>, a flag to print information messages</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>y: numerical vector, A vector of <code>-1</code> and <code>1</code> corresponding to negative and positive responses.</p> </li> <li> <p>X: numerical matrix, the stimuli.</p> </li> </ul> <p>See Also</p> <ul> <li>AbstractStimulusGenerationMethod.subject_selection_process</li> </ul>"},{"location":"utils/#tones_to_binspace","title":"tones_to_binspace","text":"<p>Spaces the values in a frequency vector into bins  determined by the stimgen object.</p> <p>ARGUMENTS:</p> <ul> <li>tones: <code>n x 1</code> vector of frequency values</li> <li>stimgen: Any object that inherets from <code>AbstractBinnedStimulusGenerationMethod</code>, used to inform the spacing (min and max freqs, number of bins)      </li> </ul> <p>OUTPUTS:</p> <ul> <li>tones_bindist: <code>n_bins x 1</code> vector in Hz which contains the values in <code>tones</code> placed into the appropriate bin (values are averaged if multiple fit into the same bin) and the bin center frequency in all bins for which there was no value in <code>tones</code>.</li> </ul> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> </ul>"},{"location":"utils/#update_hashes","title":"update_hashes","text":"<p>Updates data files that match an old hash to a new hash. Ordinarily this is not something that you want to do. However, there are some situations where the config spec changed or something was mislabeled and so the config hash does not match the hashes in the data file names. This function re-aligns the data to the config by updating the hashes.</p> <p>Arguments:</p> <ul> <li>new_hash: character vector</li> <li>old_hash: character vector</li> <li>data_dir: character vector pointing to the directory where the data files are stored.</li> </ul> <p>Outputs:</p> <ul> <li>None</li> </ul> <p>See Also</p> <ul> <li>collect_data</li> </ul>"},{"location":"utils/#view_table","title":"view_table","text":"<p>Filters data table from <code>pilot_reconstructions.m</code> and generates a figure with a uitable for easy viewing.</p> <p>Arguments:</p> <ul> <li>T: <code>table</code> generated by pilot_reconstructions</li> </ul> <p>OUTPUTS:</p> <ul> <li>1 figure</li> </ul> <p>See Also</p> <ul> <li>pilot_reconstructions</li> </ul>"},{"location":"utils/#waitforkeypress","title":"waitforkeypress","text":"<p>Wait for a keypress, ignoring mouse clicks. Returns 1 when a key is pressed. Returns -1 when the function encounters an error which usually happens when the figure is deleted.</p> <p>ARGUMENTS:</p> <ul> <li>verbose: <code>bool</code>, default: true</li> </ul> <p>OUTPUTS:</p> <ul> <li>k: <code>1 x 1</code> scalar, <code>1</code> when a key is pressed, <code>-1</code> if an error occurs</li> </ul>"},{"location":"utils/#wav2spect","title":"wav2spect","text":"<p>Reads an audio file (e.g., a .wav file) and returns a spectrum in terms of magnitudes, s (in dB), and frequencies, f (in Hz).</p> <p>ARGUMENTS:</p> <ul> <li>audio_file: <code>char</code>, path to the audio file.</li> <li>duration: <code>1x1</code> scalar, default: 0.5, the duration to crop the audio file to in seconds.</li> </ul> <p>OUTPUTS:</p> <ul> <li>s: The spectrum in dB</li> <li>f: The associated frequencies in Hz.</li> </ul>"},{"location":"utils/#white_noise","title":"white_noise","text":"<p>Generate a white noise waveform of specified length</p> <p>ARGUMENTS:</p> <ul> <li>dur: <code>1 x 1</code> positive scalar, the duration of the waveform in seconds.</li> <li>Fs: <code>1 x 1</code> positive scalar, default: 44100 The sampling rate in Hz.</li> </ul> <p>OUTPUTS:</p> <ul> <li>wav: <code>n x 1</code> numerical vector, where <code>n</code> is dur*Fs,  the white noise waveform.</li> </ul>"},{"location":"utils/#zhangpassivegamma","title":"zhangpassivegamma","text":"<p>Passive algorithm for 1-bit compressed sensing with no basis.</p>"},{"location":"utils/#references","title":"References","text":"<ul> <li>Zhang, L., Yi, J. and Jin, R., 2014, June. Efficient algorithms for robust one-bit compressive sensing. In International Conference on Machine Learning (pp. 820-828). PMLR.</li> </ul>"},{"location":"experiment/Protocols-head/","title":"Protocols","text":"<p>This folder contains all protocol functions.  These are experiments that can be run to collect data using a config file.</p>"},{"location":"experiment/Protocols/","title":"Protocols","text":"<p>This folder contains all protocol functions.  These are experiments that can be run to collect data using a config file.</p>"},{"location":"experiment/Protocols/#adjust_resynth","title":"adjust_resynth","text":"<p>Runs interactive adjustment of <code>mult</code> and <code>binrange</code> parameters for reconstruction resynthesis. Plays target sound as comparison if one is provided or included in config.</p> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>mult: <code>1 x 1</code> positive scalar, default: 0.001 initial value for the peak-sharpening <code>mult</code> parameter.</li> <li>binrange: <code>1 x 1</code> scalar, default: 60, must be between [1, 100]. The initial value for the  upper bound of the [0, binrange] dynamic range of  the peak-sharpened reconstruction.</li> <li>data_dir: <code>character vector</code>, name-value, default: empty Directory where data is stored. If blank, config.data_dir is used. </li> <li>project_dir: <code>character vector</code>, name-value, default: empty Set as an input to reduce tasks if running from <code>Protocol.m</code>.</li> <li>this_hash: <code>character vector</code>, name-value, default: empty Hash to use for output file. Generates from config if blank.</li> <li>target_sound: <code>numeric vector</code>, name-value, default: empty Target sound for comparison. Generates from config if blank.</li> <li>target_fs: <code>Positive scalar</code>, name-value, default: empty Frequency associated with target_sound</li> <li>n_trials: <code>Positive number</code>, name-value, default: inf Number of trials to use for reconstruction. Uses all data if <code>inf</code>.</li> <li>version:<code>Positive number</code>, name-value, default: 0 Question version number. Must be passed or in config.</li> <li>config_file: <code>character vector</code>, name-value, default: <code>''</code> A path to a YAML-spec configuration file.  Can be <code>'none'</code> if passing other relevant arguments.</li> <li>survey: <code>logical</code>, name-value, default: <code>true</code> Flag to run static/survey questions. If <code>false</code>, only sound comarison is shown.</li> <li>stimgen: Any <code>StimulusGenerationMethod</code>, name-value, default: <code>[]</code>, Stimgen object to use. <code>options.config</code> must be <code>'none'</code>. </li> <li>recon: <code>numeric vector</code>, name-value, default: <code>[]</code> Allows user to supply a specific reconstruction to use,  rather than generating from config. </li> <li>mult_range: <code>1 x 2 numerical vector, name-value, default:</code>[0, 1]`, The min (1,1) and max (1,2) values for mult parameter.</li> <li>binrange_range: <code>1 x 2 numerical vector, name-value, default:</code>[1, 100]`, The min (1,1) and max (1,2) values for binrange parameter.</li> <li>del_fig, <code>logical</code>, name-value, default: <code>true</code>, Flag to delete figure at the end of the experiment.</li> <li>fig: <code>matlab.ui.Figure</code>, name-value. Handle to open figure on which to display questions.</li> <li>save: <code>logical</code>, name-value, default: <code>true</code>. Flag to save the <code>mult</code> and <code>binrange</code> outputs to a <code>.csv</code> file.</li> <li>verbose: <code>logical</code>, name-value, default: <code>true</code> Flag to print information and warnings. </li> </ul> <p>OUTPUTS:</p> <ul> <li>mult: <code>1 x 1</code> scalar, the last selected value for this parameter.</li> <li>binrange: <code>1 x 1</code> scalar, the last selected value for this parameter.</li> <li>mult_binrange_XXX.csv: csv file, where XXX is the config hash. In the data directory. ONLY IF <code>save</code> param is <code>true</code>.</li> </ul> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2wav</li> </ul>"},{"location":"experiment/Protocols/#follow_up","title":"follow_up","text":"<p>Runs the follow up protocol to ask exit survey and subjective  reconstruction assessment questions. Questions are included in code/experiment/fixationscreens/FollowUp_vX, where X is the version number. Computes standard linear reconstruction,  peak-sharpened linear reconstruction, and generates config-informed white noise for comparison against target sound. Responses are saved in the specified data directory. </p> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>data_dir: <code>character vector</code>, name-value, default: empty Directory where data is stored. If blank, config.data_dir is used. </li> <li>project_dir: <code>character vector</code>, name-value, default: empty Set as an input to reduce tasks if running from <code>Protocol.m</code>.</li> <li>this_hash: <code>character vector</code>, name-value, default: empty Hash to use for output file. Generates from config if blank.</li> <li>target_sound: <code>numeric vector</code>, name-value, default: empty Target sound for comparison. Generates from config if blank.</li> <li>target_fs: <code>Positive scalar</code>, name-value, default: empty Frequency associated with target_sound</li> <li>n_trials: <code>Positive number</code>, name-value, default: inf Number of trials to use for reconstruction. Uses all data if <code>inf</code>.</li> <li>mult: <code>Positive number</code>, name-value, default: <code>NaN</code> The peak-sharpening <code>mult</code> parameter.  Must be passed if no <code>resynth_params</code> file exists.</li> <li>binrange: <code>Positive number</code>, name-value, default: 60, must be between [1, 100], the upper bound of the [0, binrange] dynamic range of the peak-sharpened reconstruction. Must be passed if no <code>resynth_params</code> file exists.</li> <li>version:<code>Positive number</code>, name-value, default: 0 Question version number. Must be passed or in config.</li> <li>config_file: <code>character vector</code>, name-value, default: <code>''</code> A path to a YAML-spec configuration file.</li> <li>survey: <code>logical</code>, name-value, default: <code>false</code> Flag to run static/survey questions. If <code>false</code>, only sound comparison is shown.</li> <li>recon: <code>numeric vector</code>, name-value, default: <code>[]</code> Allows user to supply a specific reconstruction to use,  rather than generating from config.</li> <li>n_reps: <code>1 x 1</code> positive integer, name-value, default: <code>2</code> Number of times to run the resynthesis rating questions.</li> <li>fig: <code>matlab.ui.Figure</code>, name-value. Handle to open figure on which to display questions.</li> <li>verbose: <code>logical</code>, name-value, default: <code>true</code> Flag to print information and warnings. </li> </ul> <p>OUTPUTS:</p> <ul> <li>follow_up_XXX.csv: csv file, where XXX is the config hash. In the data directory. </li> </ul>"},{"location":"experiment/Protocols/#loudnessmatch","title":"LoudnessMatch","text":"<p>Protocol for matching perceived loudness of tones to tinnitus level.</p> <pre><code>LoudnessMatch(cal_dB) \nLoudnessMatch(cal_dB, 'config', 'path2config')\nLoudnessMatch(cal_dB, 'verbose', false, 'fig', gcf, 'del_fig', false)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>max_dB_allowed_, <code>1x1</code> scalar, name-value, default: <code>95</code>. The maximum dB value at which tones can be played.  <code>cal_dB</code> must be greater than this value. Not intended to be changed from 95.</li> <li>config_file, <code>character vector</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> <li>del_fig, <code>logical</code>, name-value, default: <code>true</code>, Flag to delete figure at the end of the experiment.</li> <li>fig, <code>matlab.ui.Figure</code>, name-value. Handle to figure window in which to display instructions Function will create a new figure if none is supplied.</li> </ul> <p>OUTPUTS:</p> <ul> <li>Three <code>CSV</code> files: <code>loudness_dBs</code>, <code>loudness_noise_dB</code>, <code>loudness_tones</code> saved to config.data_dir.</li> </ul>"},{"location":"experiment/Protocols/#pitchmatch","title":"PitchMatch","text":"<p>Protocol for matching tinnitus to a single tone.</p> <p>Based on the Binary method from: Henry, James A., et al.  \"Comparison of manual and computer-automated procedures for tinnitus pitch-matching.\"  Journal of Rehabilitation Research &amp; Development 41.2 (2004).</p> <p>Henry, James A., et al.  \"Comparison of two computer-automated procedures for tinnitus pitch matching.\"  Journal of Rehabilitation Research &amp; Development 38.5 (2001).</p> <pre><code>PitchMatch(cal_dB) \nPitchMatch(cal_dB, 'config', 'path2config')\nPitchMatch(cal_dB, 'verbose', false, 'fig', gcf, 'del_fig', false)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>max_dB_allowed_, <code>1x1</code> scalar, name-value, default: <code>95</code>. The maximum dB value at which tones can be played.  <code>cal_dB</code> must be greater than this value. Not intended to be changed from 95.</li> <li>config_file, <code>character vector</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> <li>del_fig, <code>logical</code>, name-value, default: <code>true</code>, Flag to delete figure at the end of the experiment.</li> <li>fig, <code>matlab.ui.Figure</code>, name-value. Handle to figure window in which to display instructions Function will create a new figure if none is supplied.</li> </ul> <p>OUTPUTS:</p> <ul> <li>Six <code>CSV</code> files: <code>PM_tone_responses</code>, <code>PM_tones</code>,  <code>PM_octave_responses</code>, <code>PM_octaves</code>, <code>PM_tone_dBs</code>, <code>PM_octave_dBs</code> saved to config.data_dir.</li> </ul>"},{"location":"experiment/Protocols/#revcorr","title":"RevCorr","text":"<p>Reverse Correlation Protocol for Cognitive Representations of Tinnitus This function runs the main experimental procedure of this project.</p> <pre><code>RevCorr(cal_dB) \nRevCorr(cal_dB, 'config', 'path2config')\nRevCorr(cal_dB, 'verbose', false, 'fig', gcf)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>config_file, <code>character vector</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> <li>fig, <code>matlab.ui.Figure</code>, name-value. Handle to figure window in which to display instructions Function will create a new figure if none is supplied.</li> </ul> <p>OUTPUTS:</p> <ul> <li>Two <code>CSV</code> files (<code>responses</code> and <code>stimuli</code>) saved to <code>config.data_dir</code>.</li> </ul>"},{"location":"experiment/Protocols/#runallexp","title":"RunAllExp","text":"<p>This function goes one by one through each of the experimental protocols using one config file. PitchMatch is repeated 3 times by default. </p> <p>ARGUMENTS:</p> <ul> <li>cal_dB: <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>config_path: <code>character vector</code>, default: <code>''</code> A path to a YAML-spec configuration file.  If empty, a GUI is opened to navigate to the file. </li> <li>n_pm: <code>1x1</code> positive integer, the number of times to repeat  the PitchMatch protocol. Default: <code>3</code>.</li> </ul>"},{"location":"experiment/Protocols/#thresholddetermination","title":"ThresholdDetermination","text":"<p>Protocol for identifying the hearing threshold level over a range of frequencies</p> <pre><code>ThresholdDetermination(cal_dB) \nThresholdDetermination(cal_dB, 'config', 'path2config')\nThresholdDetermination(cal_dB, 'verbose', false, 'fig', gcf, 'del_fig', false\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>cal_dB, <code>1x1</code> scalar, the externally measured decibel level of a  1kHz tone at the system volume that will be used during the protocol.</li> <li>max_dB_allowed_, <code>1x1</code> scalar, name-value, default: <code>95</code>. The maximum dB value at which tones can be played.  <code>cal_dB</code> must be greater than this value. Not intended to be changed from 95.</li> <li>config_file, <code>character vector</code>, name-value, default: <code>''</code> Path to the desired config file. GUI will open for the user to select a config if no path is supplied.</li> <li>verbose, <code>logical</code>, name-value, default: <code>true</code>, Flag to show informational messages.</li> <li>del_fig, <code>logical</code>, name-value, default: <code>true</code>, Flag to delete figure at the end of the experiment.</li> <li>fig, <code>matlab.ui.Figure</code>, name-value. Handle to figure window in which to display instructions Function will create a new figure if none is supplied.</li> </ul> <p>OUTPUTS:</p> <ul> <li>Two <code>CSV</code> files: <code>threshold_dBs</code>, <code>threshold_tones</code> saved to config.data_dir.</li> </ul>"},{"location":"experiment/ata/","title":"ATA Target Sounds","text":"<p>The files within the <code>tinnitus-project/experiment/ATA</code> directory are the shortened versions of those presented on the American Tinnitus Association website (here).  They are representitive of the range of sounds experienced by those with tinnitus and function in this project as the target sound for A-X protocol experiments. These are used for experimental protocols where the subject is tasked with matching a target stimulus (\"A-X\" protocols). </p>"},{"location":"experiment/configs/","title":"Configs","text":""},{"location":"experiment/configs/#configuration-files","title":"Configuration files","text":"<p>Config files contain all of the information necessary to run trials and gather data. Configs are in <code>.yaml</code> format. These files should be carefully written before beginning any experiment to ensure the desired stimulus is generated and data are labeled and stored as intended. The name of the config file itself does not require a specific format. </p> <p>To allow for unique naming and organization, label experiment name and subject ID fields. These are not required fields for performing the experiment, but are highly encouraged. </p> <pre><code>experiment_name: paper1-buzzing-AH\nsubject_ID: AH\n</code></pre> <p>These fields describe the number of trials in the experiment. <code>n_trial_per_block</code> is the number of trials per block of the experiment. A block is a set of contiguous trials without a break a break. Subjects get a break between blocks. These are both required fields.</p> <pre><code>n_trials_per_block: 100\nn_blocks: 20\n</code></pre> <p>The total trials should be the number of trials per block times the number of blocks. This is not a required field.</p> <pre><code>total_trials: 2000\n</code></pre> <p>These \"freq\" fields describe the frequency range of the stimuli, including the minimum frequency and maximum frequency, both in Hz. The duration field describes the duration of the stimului in seconds. These are not required fields. Default values are set to <code>min_freq = 100, max_freq = 22000, and duration = 0.5</code>. These defaults are defined in the Abstract Stimulus Generation Class.</p> <pre><code>min_freq: 100\nmax_freq: 13000\nduration: 0.5\n</code></pre> <p>For a stimulus type that uses bins, the number of bins are set here. This should be a positive scalar integer.</p> <pre><code>n_bins: 100\n</code></pre> <p>This required parameter gives the stimuli type. The name is the class that defines the stimuli type without \"StimulusGeneration\".</p> <pre><code>stimuli_type: UniformPrior\n</code></pre> <p>Some stimulus generation methods have other parameters associated with them. For example, the Gaussian Prior stimulus generation method requires an <code>n_bins_filled_mean</code> and <code>n_bins_filled_var</code> property. You can see what extra parameters are required for your method by inspecting the class definition for the method (see \"Stimulus Generation\" section). If you do not overwrite values in the config, default values are used, which are described in the class definition.</p> <pre><code>min_bins: 30\nmax_bins: 30\n</code></pre> <p>For an experiment with a target signal (i.e., for pilot subjects) this field describes the full filepath to the target signal audio file.</p> <pre><code>target_audio_filepath: /home/alec/code/tinnitus-reconstruction/code/experiment/ATA/ATA_Tinnitus_Buzzing_Tone_1sec.wav\nbin_target_signal: true\n</code></pre> <p>This is the path where the output files are saved. This is not a required field. If it is is unset, it will default to <code>tinnitus-reconstruction/code/experiment/Data</code>.</p> <pre><code>data_dir: /home/alec/code/tinnitus-reconstruction/code/experiment/Data/data_pilot\n</code></pre> <p>This field determines in what form the stimuli are saved. The available options are <code>bins</code>, <code>waveform</code>, or <code>spectrum</code>. If not set, it will default to <code>waveform</code>.</p> <pre><code>stimuli_save_type: bins\n</code></pre> <p>This field indicates whether follow up questions should be asked. If it is unset, it will default to <code>false</code>.</p> <pre><code>follow_up: true\n</code></pre> <p>This field indicates what version of follow up questions to use. If it is unset, it will default to <code>1</code>. Follow up questions can be found in  <code>tinnitus-reconstruction/code/experiment/fixationscreen/FollowUp_vX</code>, where <code>X</code> is the version number. </p> <pre><code>follow_up_version: 1\n</code></pre> <p>This field indicates whether \"survey\" questinos should be asked in the follow up protocol. Survey questions can be seen in <code>tinnitus-reconstruction/code/experiment/fixationscreen/FollowUP_vX/FollowUp_Q</code>, where <code>X</code> is the version number.  These questions ask about the subject's experience during the RC protocol and are usually unnecessary to include. </p> <pre><code>follow_up_survey: false\n</code></pre> <p>To run a threshold determination, loudness matching, or pitch matching experiment,  the following two fields are additionally required.  They indicate the min and max frequencies of the test tones played during LM, TD, and PM protocols. </p> <pre><code>min_tone_freq: 500\nmax_tone_freq: 16000\n</code></pre> <p>Note: <code>stimuli_type</code>, <code>n_trials_per_block</code>, and <code>n_blocks</code>  have no effect on non-reverse correlation protocols,  but are still required to exist in a config file for the protocols to run.</p>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod-head/","title":"Abstract Binned Stimulus Generation Method","text":"<p>Abstract class describing all features common to a stimulus generation method that uses a binned representation of the signal.</p>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod-head/#abstract-properties","title":"Abstract Properties","text":"<p>These properties are automatically instantiated for subclasses, since they are not abstract themselves. Default values are given:</p> <pre><code>- n_bins = 100 % The number of bins to break the frequency spectrum into \n- unfilled_dB = -100 % The dB value of \"unfilled\" bins\n- filled_dB = 0 % The dB value of \"filled\" bins\n</code></pre>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/","title":"Abstract Binned Stimulus Generation Method","text":"<p>Abstract class describing all features common to a stimulus generation method that uses a binned representation of the signal.</p>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#abstract-properties","title":"Abstract Properties","text":"<p>These properties are automatically instantiated for subclasses, since they are not abstract themselves. Default values are given:</p> <pre><code>- n_bins = 100 % The number of bins to break the frequency spectrum into \n- unfilled_dB = -100 % The dB value of \"unfilled\" bins\n- filled_dB = 0 % The dB value of \"filled\" bins\n</code></pre>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#get_freq_bins","title":"get_freq_bins","text":"<pre><code>[binnum, Fs, nfft, frequency_vector] = self.get_freq_bins()\n</code></pre> <p>Generates a vector indicating which frequencies belong to the same bin, following a tonotopic map of audible frequency perception.</p> <p>OUTPUTS:</p> <ul> <li> <p>binnum: <code>n x 1</code> numerical vector that contains the mapping from frequency to bin number e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code></p> </li> <li> <p>Fs: <code>1x1</code> numerical scalar, the sampling rate in Hz</p> </li> <li> <p>nfft: <code>1x1</code> numerical scalar, the number of points of the full FFT</p> </li> <li> <p>frequency_vector: <code>n x 1</code> numerical vector. the frequencies that <code>binnum</code> maps to bin numbers</p> </li> </ul> <p>See Also</p> <ul> <li>AbstractStimulusGenerationMethod.get_fs</li> <li>AbstractStimulusGenerationMethod.get.nfft</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#get_empty_spectrum","title":"get_empty_spectrum","text":"<pre><code>[spect] = self.get_empty_spectrum()\n</code></pre> <p>OUTPUTS:</p> <ul> <li>spect: <code>n x 1</code> numerical vector, where <code>n</code> is equal to the number of fft points (nfft) and all values are set to <code>unfilled_dB</code>.</li> </ul> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#spect2binnedrepr","title":"spect2binnedrepr","text":"<p>Get the binned representation which is a vector containing the amplitude of the spectrum in each frequency bin.</p> <p>ARGUMENTS:</p> <ul> <li>T: <code>n_frequencies x n_trials</code> matrix representing the stimulus spectra</li> </ul> <p>OUTPUTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude for each frequency bin for each trial</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> <li>spect2binnedrepr</li> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2wav</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#binnedrepr2spect","title":"binnedrepr2spect","text":"<p>Get the stimuli spectra from a binned representation.</p> <p>ARGUMENTS:</p> <ul> <li>binned_repr: <code>n_bins x n_trials</code> representing the amplitude in each frequency bin for each trial</li> </ul> <p>OUTPUTS:</p> <ul> <li>T: <code>n_frequencies x n_trials</code> representing the stimulus spectra</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> <li>spect2binnedrepr</li> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2wav</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#binnedrepr2wav","title":"binnedrepr2wav","text":"<p>Get the peak-sharpened waveform of a binned representation. Can pass n sounds and the modifications will be applied to all.</p> <p>ARGUMENTS:</p> <ul> <li>binned_repr: <code>n_bins x n</code> numerical vector representing the amplitude in each frequency bin.</li> <li>mult: <code>n x 1</code> vector or scalar, the peak sharpening factor corresponding to each <code>binned_repr</code>.</li> <li>binrange: <code>n x 1</code> vector or scalar, must be between [1, 100], the upper bound of the dynamic range of the  stimuli from [0, binrange] corresponding to each <code>binned_repr</code>.</li> <li>new_n_bins: <code>1 x 1</code> scalar, default: <code>256</code>, the number of bins to upsample to before synthesis.</li> <li>filter: <code>logical</code>, name-value, default: <code>false</code>,  flag to filter the waveform.</li> <li>cutoff: <code>n x 2</code>, name-value, default: <code>[2000 self.max_freq]</code>, min and max cutoff frequencies corresponding to each <code>binned_repr</code>. If values satisfy min &gt; 0 &amp;&amp; max &lt; self.max_freq,  bandpass filter is used. If only min &lt; 0, highpass is used.  Otherwise, lowpass.</li> <li>order: <code>1 x 1</code> positive integer, name-value, default: <code>5</code>, the filter order.</li> </ul> <p>OUTPUTS:</p> <ul> <li>wav: <code>nfft+1 x 1</code> numerical vector representing the upsampled, peak-sharpened wavform of the binned representation.</li> <li>X: <code>nfft/2 x 1</code> numerical vector, the upsampled, peak-sparpened  spectrum of the binned representation.</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> <li>spect2binnedrepr</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#bin_signal","title":"bin_signal","text":"<pre><code>W = self.bin_signal(W)\n</code></pre> <p>Inputs a waveform, converts to a spectrum, bins the spectrum, and then converts back to a waveform.</p> <p>ARGUMENTS:</p> <p>W: <code>n x 1</code> numerical vector, the waveform Fs: <code>1x1</code> numerical scalar, the sample rate</p> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2spect</li> <li>AbstractBinnedStimulusGenerationMethod.spect2binnedrepr</li> <li>signal2spect</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod-head/","title":"Abstract Stimulus Generation Method","text":"<p>This is an abstract class describing all features common to a stimulus generation method. In addition to these features, the <code>generate_stimulus</code> method is common to every stimulus generation type. Furthermore, this abstract class contains properties common to all stimulus generation methods. </p>"},{"location":"stimgen/AbstractStimulusGenerationMethod-head/#abstract-properties","title":"Abstract Properties","text":"<p>These are automatically instantiated for subclasses, since they are not abstract themselves. Default values are shown here:</p> <pre><code>- min_freq = 100 % The minimum frequency a stimulus can have (Hz)\n- max_freq = 22e3 % The maximum frequency a stimulus can have (Hz)\n- duration = 0.5 % The duration of each stimulus (sec)\n- n_trials = 100 % The number of trials to generate\n- Fs = 44.1e3 % The sampling rate (Hz)\n</code></pre>"},{"location":"stimgen/AbstractStimulusGenerationMethod/","title":"Abstract Stimulus Generation Method","text":"<p>This is an abstract class describing all features common to a stimulus generation method. In addition to these features, the <code>generate_stimulus</code> method is common to every stimulus generation type. Furthermore, this abstract class contains properties common to all stimulus generation methods. </p>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#abstract-properties","title":"Abstract Properties","text":"<p>These are automatically instantiated for subclasses, since they are not abstract themselves. Default values are shown here:</p> <pre><code>- min_freq = 100 % The minimum frequency a stimulus can have (Hz)\n- max_freq = 22e3 % The maximum frequency a stimulus can have (Hz)\n- duration = 0.5 % The duration of each stimulus (sec)\n- n_trials = 100 % The number of trials to generate\n- Fs = 44.1e3 % The sampling rate (Hz)\n</code></pre>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#subject_selection_process","title":"subject_selection_process","text":"<pre><code>[y, spect, binned_repr] = subject_selection_process(self, signal)\n</code></pre> <p>Model of a subject performing the task. Takes in a signal (the gold standard) and returns a <code>self.n_trials x 1</code> vector of <code>-1</code> for \"no\" and <code>1</code> for \"yes\".</p>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#generate_stimuli_matrix","title":"generate_stimuli_matrix","text":"<pre><code>[stimuli_matrix, Fs, spect_matrix, binned_repr_matrix, W] = generate_stimuli_matrix(self)\n</code></pre> <p>Generates a matrix of stimuli. Explicitly calls the <code>generate_stimulus()</code> class method.</p> <p>OUTPUTS:</p> <ul> <li>stimuli_matrix: <code>n x self.n_trials</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.nfft + 1</code>.</li> <li>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</li> <li>spect_matrix: <code>m x self.n_trials</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.nfft / 2</code>, in dB.</li> <li>binned_repr_matrix: <code>self.n_bins x self.n_trials</code> numerical vector, the binned representation.</li> <li>W: <code>p x self.n_trials</code> or <code>[]</code>, where <code>p</code> is the size of the weight matrix. Only full if <code>self</code> is <code>HierarchicalGaussianStimulusGeneration</code>.</li> </ul> <p>See Also</p> <ul> <li>BernoulliStimulusGeneration.generate_stimulus</li> <li>BrimijoinStimulusGeneration.generate_stimulus</li> <li>BrimijoinGaussianSmoothedStimulusGeneration.generate_stimulus</li> <li>GaussianNoiseNoBinsStimulusGeneration.generate_stimulus</li> <li>GaussianNoiseStimulusGeneration.generate_stimulus</li> <li>GaussianPriorStimulusGeneration.generate_stimulus</li> <li>HierarchicalGaussianStimulusGeneration.generate_stimulus</li> <li>NorenaBinnedStimulusGeneration.generate_stimulus</li> <li>NorenaStimulusGeneration.generate_stimulus</li> <li>PowerDistributionStimulusGeneration.generate_stimulus</li> <li>UniformNoiseNoBinsStimulusGeneration.generate_stimulus</li> <li>UniformNoiseStimulusGeneration.generate_stimulus</li> <li>UniformPriorStimulusGeneration.generate_stimulus</li> <li>UniformPriorWeightedSampling.generate_stimulus</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#from_config","title":"from_config","text":"<p>Set properties from a struct holding config options.</p> <p>See Also</p> <ul> <li>yaml.loadFile</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#synthesize_audio","title":"synthesize_audio","text":"<p>Synthesize audio from spectrum, <code>X</code>. If <code>X</code> is an array, each column is treated as a spectrum.</p>"},{"location":"stimgen/BernoulliStimulusGeneration-head/","title":"Bernoulli Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin has a probability <code>bin_prob</code> of being filled. </p>"},{"location":"stimgen/BernoulliStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_prob = 0.3 % Probability of a bin being filled\n</code></pre>"},{"location":"stimgen/BernoulliStimulusGeneration/","title":"Bernoulli Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin has a probability <code>bin_prob</code> of being filled. </p>"},{"location":"stimgen/BernoulliStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_prob = 0.3 % Probability of a bin being filled\n</code></pre>"},{"location":"stimgen/BernoulliStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, X, binned_repr] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code>. Bins are filled with an an amplitude of <code>self.unfilled_dB</code> or <code>self.filled_dB</code>. Each bin is randomly filled with a change of being filled (amplitude = 0) with a probability of <code>self.bin_prob</code>.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>n_bins\nbin_prob\nunfilled_dB\nfilled_dB\n</code></pre>"},{"location":"stimgen/BrimijoinGaussianSmoothedStimulusGeneration-head/","title":"Brimijoin Gaussian Smoothed Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled by a Gaussian  with a maximum amplitude value chosen from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinGaussianSmoothedStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6) % Possible aplitudes for each bin (dB)\n</code></pre>"},{"location":"stimgen/BrimijoinGaussianSmoothedStimulusGeneration/","title":"Brimijoin Gaussian Smoothed Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled by a Gaussian  with a maximum amplitude value chosen from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinGaussianSmoothedStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6) % Possible aplitudes for each bin (dB)\n</code></pre>"},{"location":"stimgen/BrimijoinGaussianSmoothedStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code>. Each bin is filled between <code>self.unfilled_dB</code> and <code>0</code>  using a Gaussian power distribution rather than rectangular bins.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>n_bins\namplitude_values\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/BrimijoinStimulusGeneration-head/","title":"Brimijoin Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled with an amplitude value from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6) % Possible aplitudes for each bin (dB)\n</code></pre>"},{"location":"stimgen/BrimijoinStimulusGeneration/","title":"Brimijoin Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled with an amplitude value from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6) % Possible aplitudes for each bin (dB)\n</code></pre>"},{"location":"stimgen/BrimijoinStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code>. Bins are filled with an amplitude value chosen from <code>self.amplitude_values</code> with equal probability.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>n_bins\namplitude_values\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration-head/","title":"Gaussian Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which each frequency's amplitude is chosen according to a Gaussian distribution. This class cannot work with binned representations.</p>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract class. Defaults:</p> <pre><code>amplitude_mean = -10 % Mean of the Gaussian from which the amplitude is chosen\namplitude_var = 3 % Variance of the Gaussian from which the amplitude is chosen\n</code></pre>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/","title":"Gaussian Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which each frequency's amplitude is chosen according to a Gaussian distribution. This class cannot work with binned representations.</p>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract class. Defaults:</p> <pre><code>amplitude_mean = -10 % Mean of the Gaussian from which the amplitude is chosen\namplitude_var = 3 % Variance of the Gaussian from which the amplitude is chosen\n</code></pre>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus using a binless white-noise process.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>[]</code>, empty because this is not a binned class.</p> <p>Class Properties Used:</p> <pre><code>- amplitude_mean\n- amplitude_var\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration-head/","title":"Gaussian Noise Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled with amplitude chosen from a Gaussian distribution. This class can work with binned representations of the signals. </p>"},{"location":"stimgen/GaussianNoiseStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>amplitude_mean = -10 % Mean of the Gaussian from which the amplitude is chosen\namplitude_var = 3 % Variance of the Gaussian from which the amplitude is chosen\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/","title":"Gaussian Noise Stimulus Generation","text":"<p>This is a stimulus generation class in which each tonotopic bin is filled with amplitude chosen from a Gaussian distribution. This class can work with binned representations of the signals. </p>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>amplitude_mean = -10 % Mean of the Gaussian from which the amplitude is chosen\namplitude_var = 3 % Variance of the Gaussian from which the amplitude is chosen\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code>. Bins are filled with an amplitude value chosen randomly. from a Gaussian distribution.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n- amplitude_mean\n- amplitude_var\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration-head/","title":"Gaussian Prior Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a Gaussian distribution with known mean and variance parameters.</p>"},{"location":"stimgen/GaussianPriorStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_bins_filled_mean = 20 % Mean of the Gaussian from which number of filled bins is selected.\n- n_bins_filled_var = 1 % Variance of the Gaussian from which number of filled bins is selected.\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration/","title":"Gaussian Prior Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a Gaussian distribution with known mean and variance parameters.</p>"},{"location":"stimgen/GaussianPriorStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_bins_filled_mean = 20 % Mean of the Gaussian from which number of filled bins is selected.\n- n_bins_filled_var = 1 % Variance of the Gaussian from which number of filled bins is selected.\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code>. the bin amplitudes are <code>self.unfilled_dB</code> for an unfilled bin and <code>self.filled_dB</code> for a filled bin. Filled bins are chosen uniformly from unfilled bins, one at a time. The total number of bins-to-be-filled is chosen from a Gaussian distribution.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n- n_bins_filled_mean\n- n_bins_filled_var\n- unfilled_dB\n- filled_dB\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration-head/","title":"Hierarchical Gaussian Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by applying random weights to a  basis of Gaussians described by the class properties.</p>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has seven properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_broad = 3 % Number of \"wide\" Gaussians in the basis\n- n_med = 8 % Number of \"medium\" Gaussians in the basis \n- n_narrow = 6 % Number of \"narrow\" Gaussians in the basis\n- broad_std = 8000 % Standard deviation of the \"wide\" Gaussians\n- med_std = 2000 % Standard deviation of the \"medium\" Gaussians\n- narrow_std = 100 % Standard deviation of the \"narrow\" Gaussians\n- scale_fact = 40 % Max power (dB)\n</code></pre>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration/","title":"Hierarchical Gaussian Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by applying random weights to a  basis of Gaussians described by the class properties.</p>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has seven properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_broad = 3 % Number of \"wide\" Gaussians in the basis\n- n_med = 8 % Number of \"medium\" Gaussians in the basis \n- n_narrow = 6 % Number of \"narrow\" Gaussians in the basis\n- broad_std = 8000 % Standard deviation of the \"wide\" Gaussians\n- med_std = 2000 % Standard deviation of the \"medium\" Gaussians\n- narrow_std = 100 % Standard deviation of the \"narrow\" Gaussians\n- scale_fact = 40 % Max power (dB)\n</code></pre>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, w] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus by applying random weights to a basis of Gaussians.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>[]</code>, empty because this is not a binned class.</p> <p>w: <code>self.n_broad + self.n_med + self.n_narrow x 1</code> numerical vector, the weight vector corresponding to the each curve.</p> <p>Class Properties Used:</p> <pre><code>- scale_fact\n</code></pre> <p>See Also</p> <ul> <li>HierarchicalGaussianStimulusGeneration.get_basis</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/HierarchicalGaussianStimulusGeneration/#get_basis","title":"get_basis","text":"<pre><code>B = self.get_basis();\n</code></pre> <p>Generate a basis vector from the Gaussians stored in the class.</p> <p>OUTPUTS:</p> <p>B: <code>self.nfft / 2 x self.n_broad + self.n_med + self.n_narrow</code> numerical array, Gaussian distributions for each type specified in the class fields</p> <p>Class Properties Used:</p> <pre><code>- n_broad\n- n_med\n- n_narrow\n- broad_std\n- med_std\n- narrow_std\n</code></pre>"},{"location":"stimgen/NorenaBinnedStimulusGeneration-head/","title":"Norena Binned Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by filling the bin that houses one randomly chosen frequency.</p>"},{"location":"stimgen/NorenaBinnedStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has no properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/NorenaBinnedStimulusGeneration/","title":"Norena Binned Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by filling the bin that houses one randomly chosen frequency.</p>"},{"location":"stimgen/NorenaBinnedStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has no properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/NorenaBinnedStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus vector of length <code>self.nfft+1</code> where the bin of a randomly chosen frequency is filled.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- min_freq\n- max_freq\n- filled_dB\n- unfilled_dB\n</code></pre>"},{"location":"stimgen/NorenaStimulusGeneration-head/","title":"Norena Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by assigning one randomly chosen frequency value <code>0 dB</code>.</p>"},{"location":"stimgen/NorenaStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has no properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/NorenaStimulusGeneration/","title":"Norena Stimulus Generation","text":"<p>This is a stimulus generation class in which  stimuli are formed by assigning one randomly chosen frequency value <code>0 dB</code>.</p>"},{"location":"stimgen/NorenaStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has no properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/NorenaStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr] = generate_stimulus(self)\n</code></pre> <p>Generate a stimulus where one random Hz value is 0dB and the rest are -100dB</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>[]</code>, empty because this is not a binned class.</p>"},{"location":"stimgen/PowerDistributionStimulusGeneration-head/","title":"Power Distribution Stimulus Generation","text":"<p>This is a stimulus generation class in which the frequencies in each bin are sampled from a power distribution learned from tinnitus examples. </p>"},{"location":"stimgen/PowerDistributionStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>distribution = [] % The power distribution\ndistribution_filepath = '' % Path to the distribution file\n</code></pre>"},{"location":"stimgen/PowerDistributionStimulusGeneration/","title":"Power Distribution Stimulus Generation","text":"<p>This is a stimulus generation class in which the frequencies in each bin are sampled from a power distribution learned from tinnitus examples. </p>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>distribution = [] % The power distribution\ndistribution_filepath = '' % Path to the distribution file\n</code></pre>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#build_distribution","title":"build_distribution","text":"<p>Builds the default power distribution from ATA tinnitus sample files. Saves the distribution as a vector in dB and the corresponding frequency vector.</p> <p>ARGUMENTS:</p> <ul> <li>save_path: character vector,  the path to <code>.mat</code> file where distribution should be saved.  Default: <pre><code>pathlib.join(fileparts(mfilename('fullpath')), 'distribution.mat');\n</code></pre></li> </ul> <p>OUTPUTS:</p> <ul> <li>distribution: numeric vector, the power distribution in dB.</li> </ul> <p>See Also</p> <ul> <li>PowerDistributionStimulusGeneration.from_file</li> <li>PowerDistributionStimulusGeneration.generate_stimulus</li> </ul>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#from_file","title":"from_file","text":"<p>Loads a power distribution from a <code>.mat</code> or <code>.csv</code> file into the object.</p> <p>See Also</p> <ul> <li>PowerDistributionStimulusGeneration.build_distribution</li> </ul>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generates stimuli by assigning the power in each bin by sampling from a power distribution learned from ATA tinnitus examples.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n</code></pre>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration-head/","title":"Uniform Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which each frequency is chosen from a uniform distribution on <code>[-20, 0]</code> dB. This class does not work with binned representations of the stimuli.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class does not have any unique properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/","title":"Uniform Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which each frequency is chosen from a uniform distribution on <code>[-20, 0]</code> dB. This class does not work with binned representations of the stimuli.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class does not have any unique properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<p>Generate stimuli using a binless white-noise process with amplitudes randomly distributed between -20 and 0 dB.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>[]</code>, empty because this is not a binned class.</p>"},{"location":"stimgen/UniformNoiseStimulusGeneration-head/","title":"Uniform Noise Stimulus Generation","text":"<p>This class does not have any unique properties as its purpose is to generate a uniformly noisy stimulus signal. This class can work with binned representations of the stimuli.  </p>"},{"location":"stimgen/UniformNoiseStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/","title":"Uniform Noise Stimulus Generation","text":"<p>This class does not have any unique properties as its purpose is to generate a uniformly noisy stimulus signal. This class can work with binned representations of the stimuli.  </p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a vector of stimuli where the bin amplitudes are chosen randomly from a uniform distribution over [<code>self.unfilled_dB</code>, <code>self.filled_dB</code>] dB.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration-head/","title":"Uniform Prior Rand N Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of tonotopic bins  is randomly decided from a value in <code>n_bins_range</code> then  filled according to the <code>UniformPrior</code> method but where <code>min_bins = 1</code> and <code>max_bins = n_bins</code>.</p>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- n_bins_range = 2.^(2:7) % Possible values for n_bins to be randomly assigned\n</code></pre>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration/","title":"Uniform Prior Rand N Bins Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of tonotopic bins  is randomly decided from a value in <code>n_bins_range</code> then  filled according to the <code>UniformPrior</code> method but where <code>min_bins = 1</code> and <code>max_bins = n_bins</code>.</p>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- n_bins_range = 2.^(2:7) % Possible values for n_bins to be randomly assigned\n</code></pre>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration/#generate_stimuli_matrix","title":"generate_stimuli_matrix","text":"<pre><code>[stimuli_matrix, Fs, spect_matrix, binned_repr_matrix] = generate_stimuli_matrix(self)\n</code></pre> <p>Unique function for <code>UniformPriorRandomNBinsStimulusGeneration</code> Since self.n_bins is changed at each <code>generate_stimulus()</code> call, this function pads the matrix with NaN values. Generates a matrix of stimuli. Explicitly calls the <code>generate_stimulus()</code> class method.</p> <p>OUTPUTS:</p> <ul> <li> <p>stimuli_matrix: <code>n x self.n_trials</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.nfft + 1</code>.</p> </li> <li> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> </li> <li> <p>spect_matrix: <code>m x self.n_trials</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.nfft / 2</code>, in dB.</p> </li> <li> <p>binned_repr_matrix: <code>self.n_bins x self.n_trials</code> numerical vector, the binned representation.</p> </li> </ul> <p>See Also</p> <ul> <li>UniformPriorRandomNBinsStimulusGeneration.generate_stimulus</li> </ul>"},{"location":"stimgen/UniformPriorRandomNBinsStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<p><pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> Generates a stimulus vector by randomly assigning <code>self.n_bins</code> and filling the spectrum as in <code>UniformPriorStimulusGeneration</code>,  where <code>self.min_bins = 1</code> and <code>self.max_bins = self.n_bins</code>.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used: <pre><code>- n_bins\n- n_bins_range\n- unfilled_dB\n- filled_dB\n</code></pre></p> <p>See Also</p> <ul> <li>UniformPriorRandomNBinsStimulusGeneration.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/UniformPriorStimulusGeneration-head/","title":"Uniform Prior Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>.</p>"},{"location":"stimgen/UniformPriorStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p> <pre><code>- min_bins = 10 % Minimum number of bins that can be filled.\n- max_bins = 50 % Maximum number of bins that can be filled.\n</code></pre>"},{"location":"stimgen/UniformPriorStimulusGeneration/","title":"Uniform Prior Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>.</p>"},{"location":"stimgen/UniformPriorStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p> <pre><code>- min_bins = 10 % Minimum number of bins that can be filled.\n- max_bins = 50 % Maximum number of bins that can be filled.\n</code></pre>"},{"location":"stimgen/UniformPriorStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generates a stimulus by generating a frequency spectrum  with <code>self.unfilled_dB</code> and <code>self.filled_dB</code> dB amplitudes.  The number of filled bins is selected from a uniform distribution on <code>[self.min_bins, self.max_bins]</code>.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used: <pre><code>- n_bins\n- n_bins_filled_mean\n- n_bins_filled_var\n</code></pre></p>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration-head/","title":"Uniform Prior Weighted Sampling Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>, but which bins are filled is determined by a non-uniform distribution. </p>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_probs = [] % Assigned via `set_bin_probs()`\n- alpha_ = 1\n</code></pre>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/","title":"Uniform Prior Weighted Sampling Stimulus Generation","text":"<p>This is a stimulus generation class in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>, but which bins are filled is determined by a non-uniform distribution. </p>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation class has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_probs = [] % Assigned via `set_bin_probs()`\n- alpha_ = 1\n</code></pre>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generates a stimulus by generating a frequency spectrum  with <code>self.unfilled_dB</code> and <code>self.filled_dB</code> dB amplitudes.  The number of filled bins is selected from a uniform distribution on <code>[self.min_bins, self.max_bins]</code>,  but which bins are filled is determined from a non-uniform distribution.</p> <p>OUTPUTS:</p> <p>stim: <code>self.nfft + 1 x 1</code> numerical vector, the stimulus waveform,</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>self.nfft / 2 x 1</code> numerical vector, the half-spectrum, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>self.nfft / 2 x 1</code> numerical vector, the frequencies associated with the spectrum, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n</code></pre> <p>See Also</p> <ul> <li>UniformPriorWeightedSamplingStimulusGeneration.sample</li> </ul>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#uniformpriorweightedsamplingstimulusgeneration","title":"UniformPriorWeightedSamplingStimulusGeneration","text":"<p>class constructor</p>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#get_bin_occupancy","title":"get_bin_occupancy","text":"<pre><code>bin_occupancy = self.get_bin_occupancy();\n</code></pre> <p>Compute the bin occupancy, which is a <code>self.n_bins x 1</code> vector which counts the number of unique frequencies in each bin. This bin occupancy quantity is not related to which bins are \"filled\".</p> <p>OUTPUTS</p> <ul> <li>bin_occupancy: <code>self.n_bins x 1</code> representing the bin occupancy quantity, e.g. <code>bin_occupancy(1)</code> is the occupancy for the first bin.</li> </ul> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> </ul>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#set_bin_probs","title":"set_bin_probs","text":"<pre><code>self.set_bin_probs()\nself.set_bin_probs(1.3)\n</code></pre> <p>Sets <code>self.bin_probs</code> equal to the bin occupancy, exponentiated by <code>alpha_</code>. If <code>alpha_</code> is empty, uses the existing <code>self.alpha_</code> value. Otherwise, <code>self.alpha_</code> is set as well, and that value is used.</p> <p>ARGUMENTS</p> <ul> <li>self: the object</li> <li>alpha_: <code>1x1</code> nonnegative scalar</li> </ul> <p>See Also</p> <ul> <li>UniformPriorWeightedSamplingStimulusGeneration.get_bin_occupancy</li> </ul>"},{"location":"stimgen/UniformPriorWeightedSamplingStimulusGeneration/#sample","title":"sample","text":"<pre><code>filled_bins = self.sample(weights, values)\n</code></pre> <p>Get a vector of indices referred to bins that should be filled, by taking successive weighted samples without replacement from a list of values with associated weights.</p> <p>ARGUMENTS - n_bins_to_fill: <code>1x1</code> integral scalar indicating how many bins to fill</p> <p>OUTPUTS - filled_bins: <code>n_bins_to_fill x 1</code> vector of bin indices</p>"}]}